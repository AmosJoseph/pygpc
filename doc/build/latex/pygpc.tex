%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[shorthands=off]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Documentation of the pygpc package}
\date{Apr 08, 2019}
\release{2018}
\author{Konstantin Weise}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{pygpc package}
\label{\detokenize{pygpc:pygpc-package}}\label{\detokenize{pygpc::doc}}

\section{Subpackages}
\label{\detokenize{pygpc:subpackages}}

\subsection{pygpc.testfunctions package}
\label{\detokenize{pygpc.testfunctions:pygpc-testfunctions-package}}\label{\detokenize{pygpc.testfunctions::doc}}

\subsubsection{Submodules}
\label{\detokenize{pygpc.testfunctions:submodules}}

\subsubsection{pygpc.testfunctions.testfunctions module}
\label{\detokenize{pygpc.testfunctions:module-pygpc.testfunctions.testfunctions}}\label{\detokenize{pygpc.testfunctions:pygpc-testfunctions-testfunctions-module}}\index{pygpc.testfunctions.testfunctions (module)}\index{BfieldOutsideSphere (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.BfieldOutsideSphere}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{BfieldOutsideSphere}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Calculates the B-field outside a sphere, does not depend on conductivity after Jarvas (1987).
Dipole in SI units, positions in (mm)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"sphere\_radius"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Radius of sphere in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of dipole in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_moment"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Moment of dipole in (Ams)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"detector\_positions"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of detectors, must lie outside sphere

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{B} \textendash{} B-fields in detector positions

\item[{Return type}] \leavevmode
ndarray of float {[}1 x 3*N{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.BfieldOutsideSphere method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.BfieldOutsideSphere.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.BfieldOutsideSphere method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.BfieldOutsideSphere.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Franke (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Franke}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Franke}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Franke function {[}1{]} with 2 parameters. It is often used in regression or interpolation analysis.
It is defined in the interval {[}0, 1{]} x {[}0, 1{]}. Hampton and Doostan used in the framework of BASE-PC {[}2{]}.
\begin{equation*}
\begin{split}y = \frac{3}{4} \exp{\left(-\frac{(9 x_1 - 2)^2}{4} - \frac{(9 x_2 - 2)^2}{4}\right)} +
\frac{3}{4} \exp{\left(-\frac{(9 x_1 + 1)^2}{49} - \frac{(9 x_2 + 1)}{10}\right)} +
\frac{1}{2} \exp{\left(-\frac{(9 x_1 - 7)^2}{4} - \frac{(9 x_2 - 3)^2}{4}\right)} +
\frac{1}{5} \exp{\left(-\frac{(9 x_1 - 4)^2}{4} - (9 x_2 - 7)^2\right)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Second parameter {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-1}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.Franke method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Franke.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Franke method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Franke.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GFunction (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GFunction}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional g-function used by Saltelli and Sobol (1995) {[}1{]}.

This test function is used as an integrand for various numerical
estimation methods, including sensitivity analysis methods, because it
is fairly complex, and its sensitivity indices can be expressed
analytically. The exact value of the integral with this function as an
integrand is 1. For each index i, a lower value of a\_i indicates a higher
importance of the input variable xi.
\begin{equation*}
\begin{split}\prod_{i=1}^{N}\frac{|4 x_i - 2| + a_i}{1 + a_i}\end{split}
\end{equation*}
The recommended values of a\_i by Crestaux et al. (2007) {[}2{]} are:
\begin{equation*}
\begin{split}a_i = \frac{i-2}{2} \quad \mathrm{for\;all} \quad i=1,...,d\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"a"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_dims}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Importance factors of dimensions

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}N\_input x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-2}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GFunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GFunction.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GFunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GFunction.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzContinuous (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzContinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzContinuous}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “continuous” Genz function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
\begin{equation*}
\begin{split}y = \exp{\left(- \sum_{i=1}^{N} a_i | x_i - u_i | \right)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-3}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzContinuous method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzContinuous.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzContinuous method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzContinuous.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzCornerPeak (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzCornerPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzCornerPeak}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “CornerPeak” Genz function {[}1,2{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
Used by {[}3{]} as testfunction.
\begin{equation*}
\begin{split}y = \left( 1 + \sum_{i=1}^N a_i x_i\right)^{-(N + 1)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-4}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzCornerPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzCornerPeak.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzCornerPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzCornerPeak.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzDiscontinuous (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzDiscontinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzDiscontinuous}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “Discontinuous” Genz function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
\begin{equation*}
\begin{split}y = \exp\left( \sum_{i=1}^N a_i x_i\right) \quad \mathrm{if} \quad x_i < u_i \quad \mathrm{else} \quad 0\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-5}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzDiscontinuous method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzDiscontinuous.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzDiscontinuous method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzDiscontinuous.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzGaussianPeak (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzGaussianPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzGaussianPeak}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “GaussianPeak” Genz function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
\begin{equation*}
\begin{split}y = \exp\left( - \sum_{i=1}^{N} a_i ^2 (x_i - u_i)^2\right)\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-6}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzGaussianPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzGaussianPeak.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzGaussianPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzGaussianPeak.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzOscillatory (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzOscillatory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzOscillatory}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “Oscillatory” Genz function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
\begin{equation*}
\begin{split}y = \cos \left( 2 \pi u_1 + \sum_{i=1}^{N}a_i x_i \right)\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-7}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzOscillatory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzOscillatory.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzOscillatory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzOscillatory.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{GenzProductPeak (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzProductPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{GenzProductPeak}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “ProductPeak” Genz function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
\begin{equation*}
\begin{split}y = \prod_{i=1}^{N} \left( a_i^{-2} + (x_i - u_i)^2 \right)^{-1}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-8}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.GenzProductPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzProductPeak.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.GenzProductPeak method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.GenzProductPeak.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{HyperbolicTangent (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.HyperbolicTangent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{HyperbolicTangent}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Two-dimensional hyperbolic tangent function {[}1{]} to simulate discontinuities. Discontinuity at x1 = 0.
\begin{equation*}
\begin{split}y(x_1, x_2) = \tanh(10 x_1) + 0.2 \sin(10 x_1) + 0.3 x_2 + 0.1 \sin(5 x_1)\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter 1 {[}-1, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter 2 {[}-1, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-9}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.HyperbolicTangent method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.HyperbolicTangent.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.HyperbolicTangent method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.HyperbolicTangent.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Ishigami (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ishigami}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Ishigami}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Three-dimensional test function of Ishigami.

The Ishigami function of Ishigami \& Homma (1990) {[}1{]} is used as an example
for uncertainty and sensitivity analysis methods, because it exhibits
strong nonlinearity and nonmonotonicity. It also has a peculiar
dependence on x3, as described by Sobol’ \& Levitan (1999) {[}2{]}.
The values of a and b used by Crestaux et al. (2007) {[}3{]} and Marrel et al. (2009) {[}4{]} are: a = 7 and b = 0.1.
\begin{equation*}
\begin{split}y = \sin(x_1) + a \sin(x_2)^2 + b x_3^4 \sin(x_1)\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}-pi, pi{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Second parameter defined in {[}-pi, pi{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x3"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Third parameter defined in {[}-pi, pi{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"a"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} shape parameter (a=7)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"b"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} shape parameter (b=0.1)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-10}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.Ishigami method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ishigami.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Ishigami method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ishigami.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Lim2002 (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Lim2002}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Lim2002}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Two-dimensional test function of Lim et al. (2002) {[}1{]}.

This function is a polynomial in two dimensions, with terms up to degree
5. It is nonlinear, and it is smooth despite being complex, which is
common for computer experiment functions.
\begin{equation*}
\begin{split}y = 9 + \frac{5}{2} x_1 - \frac{35}{2} x_2 + \frac{5}{2} x_1 x_2 + 19 x_2^2 -
\frac{15}{2} x_1^3 - \frac{5}{2} x_1 x_2^2 - \frac{11}{2} x_2^4 + x_1^3 x_2^2\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Second parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-11}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.Lim2002 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Lim2002.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Lim2002 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Lim2002.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{ManufactureDecay (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.ManufactureDecay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{ManufactureDecay}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional manufacture decay function {[}1{]}. It is defined in the interval {[}0, 1{]} x … x {[}0, 1{]}.
Hampton and Doostan used in the framework of BASE-PC {[}1{]}.
\begin{equation*}
\begin{split}y = \exp{\left(2 - \sum_{i=1}^{N} x_i \frac{\sin(i+1)}{i + 1}\right)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}0, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in {[}0, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-12}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.ManufactureDecay method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.ManufactureDecay.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.ManufactureDecay method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.ManufactureDecay.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{MovingParticleFrictionForce (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.MovingParticleFrictionForce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{MovingParticleFrictionForce}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Differential equation describing a particle moving under the influence of a
potential field and of a friction force {[}1{]}.
\begin{equation*}
\begin{split}\frac{d^2 x}{dt^2} + f \frac{dx}{dt} = -\frac{35}{2} x^3 + \frac{15}{2} x\end{split}
\end{equation*}
with:
\begin{equation*}
\begin{split}x_1 = x\end{split}
\end{equation*}\begin{equation*}
\begin{split}x_2 = \frac{dx}{dt}\end{split}
\end{equation*}
we get a system of two 1st order ODE
\begin{equation*}
\begin{split}\frac{d x_1}{dt} = x_2\end{split}
\end{equation*}\begin{equation*}
\begin{split}\frac{d x_2}{dt} = -\frac{35}{2} x_1^3 + \frac{15}{2} x_1 - f x_2\end{split}
\end{equation*}
Discontinuity at randomly perturbed initial value x0 = X0 + delta\_X * xi = 0.05 - 0.2 * 0.25
and two stable fixed points:
\begin{equation*}
\begin{split}x = -\sqrt{15/35} \mathrm{for} \xi < -0.25\end{split}
\end{equation*}\begin{equation*}
\begin{split}x = +\sqrt{15/35} \mathrm{for} \xi > -0.25\end{split}
\end{equation*}
xi is uniform distributed {[}-1, 1{]}

Mean value: 0.163663
Standard deviation: 0.633865691
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Pertubation xi of initial value x0 (x0 = X0 + xi) {[}-1, 1{]}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} x(t=10.)

\item[{Return type}] \leavevmode
ndarray of float {[}1 x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-13}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.MovingParticleFrictionForce method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.MovingParticleFrictionForce.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.MovingParticleFrictionForce method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.MovingParticleFrictionForce.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{OakleyOhagan2004 (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.OakleyOhagan2004}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{OakleyOhagan2004}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

15-dimensional test function of Oakley and O’Hagan (2004) {[}1{]}.

This function’s a-coefficients are chosen so that 5 of the input
variables contribute significantly to the output variance, 5 have a
much smaller effect, and the remaining 5 have almost no effect on the
output variance.
\begin{equation*}
\begin{split}y = \mathbf{a}_1^T\mathbf{x} + \mathbf{a}_2^T \sin(\mathbf{x}) + \mathbf{a}_3^T \cos(\mathbf{x}) +
\mathbf{x}^T\mathbf{M}\mathbf{x}\end{split}
\end{equation*}
The parameter vectors a and matrix M are in /pygpc/pck/data/oakley\_ohagan\_2004.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1...15"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Input data, xi \textasciitilde{} N(mu=0, sigma=1), for all i = 1, 2,…, 15.

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}N\_input x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.OakleyOhagan2004 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.OakleyOhagan2004.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.OakleyOhagan2004 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.OakleyOhagan2004.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Peaks (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Peaks}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Peaks}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Two-dimensional peaks function.

y = Peaks(x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter 2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x3"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter 3

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{y} (\sphinxstyleemphasis{ndarray of float {[}n\_grid x n\_out{]}}) \textendash{} Output data

\item {} 
\sphinxstylestrong{misc} (\sphinxstyleemphasis{dict or list of dict {[}n\_grid{]}}) \textendash{} Additional data, will be saved under its keys in the .hdf5 file during gPC simulations for every grid point

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-14}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.Peaks method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Peaks.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Peaks method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Peaks.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{PotentialDipole3Layers (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialDipole3Layers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{PotentialDipole3Layers}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Calculates the electric potential in a 3-layered sphere caused by a dipole after Ary et al. (1981).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"radii"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Radius of each of the 3 layers (innermost to outermost) in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"cond\_brain\_scalp"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of the brain and scalp layers in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"cond\_skull"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of the skull layer in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of the dipole, in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_moment"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Moment of dipole, in (Cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"surface\_points"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of positions where the potential should be calculated in (mm)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{potential} \textendash{} Values of the electric potential, in (V)

\item[{Return type}] \leavevmode
ndarray of float {[}1 x n\_out{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.PotentialDipole3Layers method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialDipole3Layers.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.PotentialDipole3Layers method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialDipole3Layers.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{PotentialHomogeneousDipole (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialHomogeneousDipole}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{PotentialHomogeneousDipole}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Calculates the surface potential generated by a dipole inside a homogeneous conducting sphere after Yao (2000).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"sphere\_radius"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Radius of sphere in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"conductivity"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of medium in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of dipole in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_moment"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Moment of dipole in (Cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"detector\_positions"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of detectors, will be projected into the sphere surface in (mm)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{potential} \textendash{} Potential at the points

\item[{Return type}] \leavevmode
ndarray of float {[}1 x n\_out{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.PotentialHomogeneousDipole method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialHomogeneousDipole.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.PotentialHomogeneousDipole method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.PotentialHomogeneousDipole.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Ridge (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ridge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Ridge}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional “Ridge” function {[}1{]} (and also used as testfunction therein).
Typically defined in the interval {[}-4, 4{]} x … x {[}-4, 4{]}.
\begin{equation*}
\begin{split}y = \sum_{i=1}^{N}x_i + 0.25 \left( \sum_{i=1}^{N}x_i \right)^2 + 0.025 \left( \sum_{i=1}^{N}x_i \right)^3\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter defined in e.g. {[}-4, 4{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in e.g. {[}-4, 4{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter defined in e.g. {[}-4, 4{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-15}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.Ridge method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ridge.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Ridge method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Ridge.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{SphereFun (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereFun}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{SphereFun}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

N-dimensional sphere function with zero mean.
\begin{equation*}
\begin{split}y = \sum_{i=1}^{N}x_i^2\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} First parameter {[}-1, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xi"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} i-th parameter defined in {[}-1, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"xN"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Nth parameter {[}-1, 1{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-16}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.SphereFun method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereFun.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.SphereFun method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereFun.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{SphereModel (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{SphereModel}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Calculates the electric potential in a 3-layered sphere caused by point-like electrodes
after Rush and Driscoll (1969) {[}1{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"sigma\_1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of the innermost layer, in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"sigma\_2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of the intermediate layer, in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"sigma\_3"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Conductivity of the outermost layer, in (S/m)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"radii"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Radius of each of the 3 layers (innermost to outermost), in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"anode\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of the anode\_pos, in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"cathode\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3 x 1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of cathode\_pos, in (mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"p"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Positions where the potential should be calculated, in (mm)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{potential} \textendash{} Values of the electric potential, in (V)

\item[{Return type}] \leavevmode
ndarray of float {[}1 x n\_out{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.SphereModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereModel.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.SphereModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SphereModel.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{SurfaceCoverageSpecies (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SurfaceCoverageSpecies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{SurfaceCoverageSpecies}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Differential equation describing the time-evolution of the surface coverage rho {[}0, 1{]} for a given species {[}1{]}.
This problem has one or two fixed points according to the value of the recombination rate beta and it exhibits
smooth dependence on the other parameters. The statistics of the solution at t=1 are investigated considering
uncertainties in the initial coverage rho\_0 and in the reaction parameter beta. Additionally uncertainty
in the surface absorption rate alpha can be considered to make the problem 3-dimensional.
Gamma=0.01 denotes the desorption rate.
\begin{equation*}
\begin{split}\frac{d\rho}{dt} = \alpha (1 - \rho) - \gamma \rho - \beta (\rho - 1)^2 \rho\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"rho\_0"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Initial value rho(t=0) (uniform distributed {[}0, 1{]})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"beta"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Recombination rate (uniform distributed {[}0, 20{]})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"alpha"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Surface absorption rate (1 or uniform distributed {[}0.1, 2{]})

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} rho(t-\textgreater{}1)

\item[{Return type}] \leavevmode
ndarray of float {[}1 x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pygpc-testfunctions-17}.pdf}
\end{figure}
\index{simulate() (pygpc.testfunctions.testfunctions.SurfaceCoverageSpecies method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SurfaceCoverageSpecies.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.SurfaceCoverageSpecies method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.SurfaceCoverageSpecies.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{TMSEfieldSphere (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.TMSEfieldSphere}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{TMSEfieldSphere}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

Calculate the E-field in a sphere caused by external magnetic dipoles after Heller and van Hulsteyn (1992).
The results are independent of conductivity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_pos"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{M x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position of dipoles, must be outside sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"dipole\_moment"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{m x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Moment of dipoles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"didt"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Variation rate of current in the coil

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"positions"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Position where fields should be calculated, must lie inside sphere in (mm)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{E} \textendash{} E-fields at detector positions

\item[{Return type}] \leavevmode
ndarray of float {[}1 x 3*N{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.TMSEfieldSphere method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.TMSEfieldSphere.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.TMSEfieldSphere method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.TMSEfieldSphere.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{Welch1992 (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Welch1992}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{Welch1992}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

20-dimensional test function of Welch et al. (1992) {[}1{]}.

For input variable screening purposes, it can be found that some input
variables of this function have a very high effect on the output,
compared to other input variables. As Welch et al. (1992) {[}1{]} point out,
interactions and nonlinear effects make this function challenging.
\begin{align*}\!\begin{aligned}
y = \frac{5 x_{12}}{1 + x_1} + 5 (x_4 - x_{20})^2 + x_5 + 40 x_{19}^3 + 5 x_{19} + 0.05 x_2
+ 0.08 x_3 - 0.03 x_6 + 0.03 x_7 - 0.09 x_9 - 0.01 x_{10} -\\
0.07 x_{11} + 0.25 x_{13}^2 - 0.04 x_{14} + 0.06 x_{15} - 0.01 x_{17} - 0.03 x_{18}\\
\end{aligned}\end{align*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1...x20"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Input data, xi \textasciitilde{} U(-0.5, 0.5), for all i = 1,…, 20.

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.Welch1992 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Welch1992.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.Welch1992 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.Welch1992.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{WingWeight (class in pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.WingWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{WingWeight}}}{\emph{p}, \emph{context=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.AbstractModel.AbstractModel}}}}}

10-dimensional test function which models a light aircraft wing from Forrester et al. (2008) {[}1{]}
\begin{equation*}
\begin{split}y = \frac{0.036 x_1^{0.758} x_2^{0.0035} x_3}{\cos(x_4)^2)^{0.6}} x_5^{0.006} x_6^{0.04}
\left( \frac{100 x_7}{\cos(x_4)}\right)^{-0.3} (x_8 x_9)^{0.49} + x_1 x_{10}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x1"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x1(Sw) {[}150, 200{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x2"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x2(Wfw) {[}220, 300{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x3"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x3(A) {[}6, 10{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x4"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x4(Lambda) {[}-10, 10{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x5"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x5(q) {[}16, 45{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x6"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x6(lambda) {[}0.5, 1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x7"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x7(tc) {[}0.08, 0.18{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x8"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x8(Nz) {[}2.5, 6{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x9"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x9(Wdg) {[}1700, 2500{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{"x10"}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x10(Wp) {[}0.025, 0.08{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Output data

\item[{Return type}] \leavevmode
float or ndarray of float {[}n\_grid x 1{]}

\end{description}\end{quote}
\subsubsection*{Notes}
\index{simulate() (pygpc.testfunctions.testfunctions.WingWeight method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.WingWeight.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.testfunctions.testfunctions.WingWeight method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.WingWeight.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}


\end{fulllineitems}

\index{plot\_testfunction() (in module pygpc.testfunctions.testfunctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc.testfunctions:pygpc.testfunctions.testfunctions.plot_testfunction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.testfunctions.testfunctions.}}\sphinxbfcode{\sphinxupquote{plot\_testfunction}}}{\emph{testfunction\_name}, \emph{parameters}, \emph{constants=None}, \emph{output\_idx=0}}{}
Plot 1D or 2D testfunctions for documentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{testfunction\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of testfunction AbstractModel class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{OrdererdDict}}) \textendash{} Dictionary containing the 1D coordinates as ndarrays, where the testfunction is evaluated (will be tensorized)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{constants}} (\sphinxstyleliteralemphasis{\sphinxupquote{OrderedDict}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Dictionary containing the (remaining) parameters treated as constants

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of output quantity to plot

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}plot\textgreater{}} \textendash{} Plot showing the QoI of the testfunction in 1D or 2D

\item[{Return type}] \leavevmode
matplotlib figure

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{pygpc.testfunctions:module-pygpc.testfunctions}}\label{\detokenize{pygpc.testfunctions:module-contents}}\index{pygpc.testfunctions (module)}

\section{Submodules}
\label{\detokenize{pygpc:submodules}}

\section{pygpc.AbstractModel module}
\label{\detokenize{pygpc:module-pygpc.AbstractModel}}\label{\detokenize{pygpc:pygpc-abstractmodel-module}}\index{pygpc.AbstractModel (module)}\index{AbstractModel (class in pygpc.AbstractModel)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.AbstractModel.}}\sphinxbfcode{\sphinxupquote{AbstractModel}}}{\emph{p}, \emph{context=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Abstract base class for the SimulationWrapper.
This base class provides basic functions for serialization/deserialization and printing progress.
It cannot be used directly, but a derived class implementing the “simulate” method must be created.
\index{get\_seq\_number() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.get_seq_number}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_seq\_number}}}{}{}
\end{fulllineitems}

\index{increment\_ctr() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.increment_ctr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{increment\_ctr}}}{}{}
This functions increments the global counter by 1.

\end{fulllineitems}

\index{print\_progress() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.print_progress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_progress}}}{\emph{func\_time=None}, \emph{read\_from\_file=False}}{}
This function prints the progress according to the current context and global\_counter.

\end{fulllineitems}

\index{read\_previous\_results() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.read_previous_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_previous\_results}}}{\emph{coords}}{}
This functions reads previous results from the hard disk (if present).
When reading from the array containing the results, the current
grid-index (i\_grid) is considered to maintain the order of the results when the
SimulationModels are executed in parallel. If the function evaluated the results in parallel
internally, i\_grid is a range {[}i\_grid\_min, i\_grid\_max{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sims x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Grid coordinates the simulations are conducted with

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None} \textendash{} if no serialized results could be found or does not fit to grid

\item {} 
\sphinxstyleemphasis{list} \textendash{} data at coords

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simulate() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{process\_id=None}}{}
This abstract method must be implemented by the subclass.
It should perform the simulation task depending on the input\_values provided to the object on instantiation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{process\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} A unique identifier; no two processes of the pool will run concurrently with the same identifier

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
This abstract method must be implemented by the subclass.
It should perform the validation task depending on the parameters defined in the problem.
In cases, the model may not run correctly for some parameter combinations, this function changes the definition
of the random parameters and the constants.

\end{fulllineitems}

\index{write\_results() (pygpc.AbstractModel.AbstractModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.AbstractModel.AbstractModel.write_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_results}}}{\emph{data\_dict}}{}
This function writes the data to a file on hard disk.
When writing the data the current grid-index (i\_grid) is considered.
The data are written to the row corresponding i\_grid in order to
maintain the order of the results when the SimulationModels are
executed in parallel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict of ndarray}}) \textendash{} Dictionary, containing the data to write in an .hdf5 file. The keys are the dataset names.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.Algorithm module}
\label{\detokenize{pygpc:module-pygpc.Algorithm}}\label{\detokenize{pygpc:pygpc-algorithm-module}}\index{pygpc.Algorithm (module)}\index{Algorithm (class in pygpc.Algorithm)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Algorithm.Algorithm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Algorithm.}}\sphinxbfcode{\sphinxupquote{Algorithm}}}{\emph{problem}, \emph{options}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Class for GPC algorithms

\end{fulllineitems}

\index{RegAdaptive (class in pygpc.Algorithm)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Algorithm.RegAdaptive}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Algorithm.}}\sphinxbfcode{\sphinxupquote{RegAdaptive}}}{\emph{problem}, \emph{options}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Algorithm.Algorithm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Algorithm.Algorithm}}}}}

Adaptive regression approach based on leave one out cross validation error estimation
\index{run() (pygpc.Algorithm.RegAdaptive method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Algorithm.RegAdaptive.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
Runs adaptive gPC algorithm to solve problem.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{gpc} (\sphinxstyleemphasis{GPC object instance}) \textendash{} GPC object containing all information i.e., Problem, Model, Grid, Basis, RandomParameter instances

\item {} 
\sphinxstylestrong{coeffs} (\sphinxstyleemphasis{ndarray of float {[}n\_basis x n\_out{]}}) \textendash{} GPC coefficients

\item {} 
\sphinxstylestrong{res} (\sphinxstyleemphasis{ndarray of float {[}n\_grid x n\_out{]}}) \textendash{} Simulation results at n\_grid points of the n\_out output variables

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Static (class in pygpc.Algorithm)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Algorithm.Static}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Algorithm.}}\sphinxbfcode{\sphinxupquote{Static}}}{\emph{problem}, \emph{options}, \emph{grid}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Algorithm.Algorithm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Algorithm.Algorithm}}}}}

Static gPC algorithm
\index{run() (pygpc.Algorithm.Static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Algorithm.Static.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
Runs static gPC algorithm to solve problem.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{gpc} (\sphinxstyleemphasis{GPC object instance}) \textendash{} GPC object containing all information i.e., Problem, Model, Grid, Basis, RandomParameter instances

\item {} 
\sphinxstylestrong{coeffs} (\sphinxstyleemphasis{ndarray of float {[}n\_basis x n\_out{]}}) \textendash{} GPC coefficients

\item {} 
\sphinxstylestrong{res} (\sphinxstyleemphasis{ndarray of float {[}n\_grid x n\_out{]}}) \textendash{} Simulation results at n\_grid points of the n\_out output variables

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.Basis module}
\label{\detokenize{pygpc:module-pygpc.Basis}}\label{\detokenize{pygpc:pygpc-basis-module}}\index{pygpc.Basis (module)}\index{Basis (class in pygpc.Basis)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Basis.}}\sphinxbfcode{\sphinxupquote{Basis}}}
Basis class of gPC
\index{b (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}}
Parameter wise basis function objects used in gPC.
Multiplying all elements in a row at location xi = (x1, x2, …, x\_dim) yields the global basis function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of BasisFunction object instances {[}n\_basis x n\_dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{b\_gpu (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.b_gpu}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_gpu}}}
???
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
???

\end{description}\end{quote}

\end{fulllineitems}

\index{b\_id (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.b_id}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_id}}}
Unique IDs of global basis functions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of UUID objects (version 4) {[}n\_basis{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{b\_norm (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.b_norm}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_norm}}}
Normalization factor of individual basis functions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ndarray {[}n\_basis x dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{b\_norm\_basis (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.b_norm_basis}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_norm\_basis}}}
Normalization factor of global basis functions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ndarray {[}n\_basis x 1{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{dim (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.dim}}\pysigline{\sphinxbfcode{\sphinxupquote{dim}}}
Number of variables

\end{fulllineitems}

\index{n\_basis (pygpc.Basis.Basis attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.n_basis}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_basis}}}
Total number of (global) basis function
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{extend\_basis() (pygpc.Basis.Basis method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.extend_basis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend\_basis}}}{\emph{b\_added}}{}
Extend set of basis functions and update gpc matrix (append columns).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{b\_added}} (\sphinxstyleliteralemphasis{\sphinxupquote{2D list of BasisFunction instances}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_b\_added x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Individual BasisFunctions to add

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_b\_norm() (pygpc.Basis.Basis method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.init_b_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_b\_norm}}}{}{}
Construct array of scaling factors self.b\_norm {[}n\_basis x dim{]} and self.b\_norm\_basis {[}n\_basis x 1{]}
to normalize basis functions \textless{}psi\textasciicircum{}2\textgreater{} = int(psi\textasciicircum{}2*p)dx

\end{fulllineitems}

\index{init\_basis\_sgpc() (pygpc.Basis.Basis method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Basis.Basis.init_basis_sgpc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_basis\_sgpc}}}{\emph{problem}, \emph{order}, \emph{order\_max}, \emph{order\_max\_norm}, \emph{interaction\_order}}{}
Initializes basis functions for standard gPC.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{problem}} (\sphinxstyleliteralemphasis{\sphinxupquote{Problem object}}) \textendash{} GPC Problem to analyze

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}) \textendash{} Maximum individual expansion order
Generates individual polynomials also if maximum expansion order in order\_max is exceeded

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Maximum global expansion order.
The maximum expansion order considers the sum of the orders of combined polynomials together with the
chosen norm “order\_max\_norm”. Typically this norm is 1 such that the maximum order is the sum of all
monomial orders.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_max\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Norm for which the maximum global expansion order is defined {[}0, 1{]}. Values \textless{} 1 decrease the total number
of polynomials in the expansion such that interaction terms are penalized more. This truncation scheme
is also referred to “hyperbolic polynomial chaos expansion” such that sum(a\_i\textasciicircum{}q)\textasciicircum{}1/q \textless{}= p,
where p is order\_max and q is order\_max\_norm (for more details see eq. (27) in {[}1{]}).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interaction\_order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random variables, which can interact with each other
All polynomials are ignored, which have an interaction order greater than specified

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{equation*}
\begin{split}\begin{tabular}{l*{4}{c}}
 Polynomial Index    & Dimension 1 & Dimension 2 & ... & Dimension M \\
\hline
 Basis 1             & [Order D1] & [Order D2] & \vdots & [Order M] \\
 Basis 2             & [Order D1] & [Order D2] & \vdots & [Order M] \\
\vdots              & [Order D1] & [Order D2] & \vdots  & [Order M] \\
 Basis N           & [Order D1] & [Order D2] & \vdots & [Order M] \\
\end{tabular}\end{split}
\end{equation*}
Adds Attributes:
\begin{description}
\item[{b: list of BasisFunction object instances {[}n\_basis x n\_dim{]}}] \leavevmode
Parameter wise basis function objects used in gPC.
Multiplying all elements in a row at location xi = (x1, x2, …, x\_dim) yields the global basis function.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.BasisFunction module}
\label{\detokenize{pygpc:module-pygpc.BasisFunction}}\label{\detokenize{pygpc:pygpc-basisfunction-module}}\index{pygpc.BasisFunction (module)}\index{BasisFunction (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{BasisFunction}}}{\emph{p}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Abstract class of basis functions.
This base class provides basic properties and methods for the basis functions.
It cannot be used directly, but inherits properties and methods to the specific basis function sub classes.
\index{\_\_call\_\_() (pygpc.BasisFunction.BasisFunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.BasisFunction.__call__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{x}}{}
Evaluates basis function for argument x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Argument for which the basis function is evaluated

\item[{Returns}] \leavevmode
\sphinxstylestrong{y} \textendash{} Function value of basis function at argument x

\item[{Return type}] \leavevmode
float or ndarray of float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Hermite (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.Hermite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{Hermite}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

Hermite basis function used in the orthogonal gPC to model normal distributed random variables.

\end{fulllineitems}

\index{Jacobi (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.Jacobi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{Jacobi}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

Jacobi basis function used in the orthogonal gPC to model beta distributed random variables.

\end{fulllineitems}

\index{Rect (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.Rect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{Rect}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

Rectangular basis function used in the non-orthogonal gPC.

\end{fulllineitems}

\index{SigmoidDown (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.SigmoidDown}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{SigmoidDown}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

SigmoidDown (from 0 to 1) basis function used in the non-orthogonal gPC.

\end{fulllineitems}

\index{SigmoidUp (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.SigmoidUp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{SigmoidUp}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

SigmoidUp (from 0 to 1) basis function used in the non-orthogonal gPC.

\end{fulllineitems}

\index{StepDown (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.StepDown}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{StepDown}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

StepDown (from 1 to 0) basis function used in the non-orthogonal gPC.

\end{fulllineitems}

\index{StepUp (class in pygpc.BasisFunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.BasisFunction.StepUp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.BasisFunction.}}\sphinxbfcode{\sphinxupquote{StepUp}}}{\emph{p}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.BasisFunction.BasisFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.BasisFunction.BasisFunction}}}}}

StepUp (from 0 to 1) basis function used in the non-orthogonal gPC.

\end{fulllineitems}



\section{pygpc.Computation module}
\label{\detokenize{pygpc:module-pygpc.Computation}}\label{\detokenize{pygpc:pygpc-computation-module}}\index{pygpc.Computation (module)}\index{Computation() (in module pygpc.Computation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.Computation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Computation.}}\sphinxbfcode{\sphinxupquote{Computation}}}{\emph{n\_cpu}}{}
Helper function to initialize the Computation class.
n\_cpu = 0 : use this if the model is capable of to evaluate several parameterizations in parallel
n\_cpu = 1 : the model is called in serial for every paramerization.
n\_cpu \textgreater{} 1 : A multiprocessing.Pool will be opened and n\_cpu parameterizations are calculated in parallel
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n\_cpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of CPU cores to use

\item[{Returns}] \leavevmode
\sphinxstylestrong{obj} \textendash{} Object instance of Computation class

\item[{Return type}] \leavevmode
object instance of Computation class

\end{description}\end{quote}

\end{fulllineitems}

\index{ComputationFuncPar (class in pygpc.Computation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationFuncPar}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Computation.}}\sphinxbfcode{\sphinxupquote{ComputationFuncPar}}}{\emph{n\_cpu}}{}
Computation sub-class to run the model using a the models internal parallelization
\index{close() (pygpc.Computation.ComputationFuncPar method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationFuncPar.close}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{close}}}{}{}
Closes the pool

\end{fulllineitems}

\index{run() (pygpc.Computation.ComputationFuncPar method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationFuncPar.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{model}, \emph{problem}, \emph{coords}, \emph{coords\_norm=None}, \emph{i\_iter=None}, \emph{i\_subiter=None}, \emph{fn\_results=None}, \emph{print\_func\_time=False}}{}
Runs model evaluations for parameter combinations specified in coords array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{Model object}}) \textendash{} Model object instance of model to investigate (derived from AbstractModel class, implemented by user)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{problem}} (\sphinxstyleliteralemphasis{\sphinxupquote{Problem class instance}}) \textendash{} GPC Problem under investigation, includes the parameters of the model (constant and random)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sims}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Set of n\_sims parameter combinations to run the model with (only the random parameters!).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sims}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Set of n\_sims parameter combinations to run the model with (normalized coordinates {[}-1, 1{]}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of main-iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i\_subiter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of sub-iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} If provided, model evaluations are saved in fn\_results.hdf5 file and gpc object in fn\_results.pkl file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_func\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Print time of single function evaluation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{res} \textendash{} n\_sims simulation results of the n\_out output quantities of the model under investigation.

\item[{Return type}] \leavevmode
ndarray of float {[}n\_sims x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ComputationPoolMap (class in pygpc.Computation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationPoolMap}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Computation.}}\sphinxbfcode{\sphinxupquote{ComputationPoolMap}}}{\emph{n\_cpu}}{}
Computation sub-class to run the model using a processing pool for parallelization
\index{close() (pygpc.Computation.ComputationPoolMap method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationPoolMap.close}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{close}}}{}{}
Closes the pool

\end{fulllineitems}

\index{run() (pygpc.Computation.ComputationPoolMap method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.ComputationPoolMap.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{model}, \emph{problem}, \emph{coords}, \emph{coords\_norm=None}, \emph{i\_iter=None}, \emph{i\_subiter=None}, \emph{fn\_results=None}, \emph{print\_func\_time=False}}{}
Runs model evaluations for parameter combinations specified in coords array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{Model object}}) \textendash{} Model object instance of model to investigate (derived from AbstractModel class, implemented by user)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{problem}} (\sphinxstyleliteralemphasis{\sphinxupquote{Problem class instance}}) \textendash{} GPC Problem under investigation, includes the parameters of the model (constant and random)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sims}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Set of n\_sims parameter combinations to run the model with (only the random parameters!).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sims}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Set of n\_sims parameter combinations to run the model with (normalized coordinates {[}-1, 1{]}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of main-iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i\_subiter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of sub-iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} If provided, model evaluations are saved in fn\_results.hdf5 file and gpc object in fn\_results.pkl file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_func\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Print time of single function evaluation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{res} \textendash{} n\_sims simulation results of the n\_out output quantities of the model under investigation.

\item[{Return type}] \leavevmode
ndarray of float {[}n\_sims x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{compute\_cluster() (in module pygpc.Computation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Computation.compute_cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Computation.}}\sphinxbfcode{\sphinxupquote{compute\_cluster}}}{\emph{algorithms}, \emph{nodes}, \emph{start\_scheduler=True}}{}
Computes Algorithm instances on compute cluster composed of nodes. The first node is also the dispy-scheduler.
Afterwards, the dispy-nodes are started on every node. On every node, screen sessions are started with the names
“scheduler” and “node”, where the scheduler and the nodes are residing, respectively.
They can be accessed by “screen -rD scheduler” or “screen -rD node” when connected via ssh to the machines.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{algorithms}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Algorithm instances}}) \textendash{} Algorithm instances initialized with different gPC problems and/or models

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Node names

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_scheduler}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Starts a scheduler on the first machine in the nodes list or not. Set this to False if a scheduler is already
running somewhere on the cluster.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pygpc.EGPC module}
\label{\detokenize{pygpc:module-pygpc.EGPC}}\label{\detokenize{pygpc:pygpc-egpc-module}}\index{pygpc.EGPC (module)}\index{EGPC (class in pygpc.EGPC)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.EGPC.}}\sphinxbfcode{\sphinxupquote{EGPC}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.GPC.GPC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.GPC.GPC}}}}}
\index{get\_approximation() (pygpc.EGPC.EGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_approximation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_approximation}}}{\emph{coeffs=None}, \emph{xi=None}, \emph{output\_idx=None}}{}
Calculates the gPC approximation in points with output\_idx and normalized parameters xi (interval: {[}-1, 1{]}).

pce = EGPC.get\_approximation(coeffs=None, xi=None, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Gpc coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xi}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Point in variable space to evaluate local sensitivity in normalized coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Index of output quantities to consider (Default: all outputs).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pce} \textendash{} Gpc approximation at normalized coordinates xi.

\item[{Return type}] \leavevmode
{[}N\_xi x N\_out{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_global\_sens() (pygpc.EGPC.EGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_global_sens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_global\_sens}}}{\emph{coeffs}}{}
Determine the global derivative based sensitivity coefficients after Xiu (2009) {[}1{]}.

global\_sens = EGPC.get\_global\_sens(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Gpc coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{global\_sens} \textendash{} Global derivative based sensitivity coefficients

\item[{Return type}] \leavevmode
{[}dim x N\_out{]} np.ndarray

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{get\_local\_sens() (pygpc.EGPC.EGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_local_sens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_local\_sens}}}{\emph{coeffs}, \emph{xi}}{}
Determine the local derivative based sensitivity coefficients in the point of interest xi
(normalized coordinates {[}-1, 1{]}).

local\_sens = EGPC.calc\_localsens(coeffs, xi)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Gpc coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xi}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Point in variable space to evaluate local sensitivity in (normalized coordinates!)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{local\_sens} \textendash{} Local sensitivity

\item[{Return type}] \leavevmode
{[}dim x N\_out{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mean() (pygpc.EGPC.EGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_mean}}}{\emph{coeffs}}{}
Calculate the expected mean value.

mean = SGPC.get\_mean(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Gpc coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{mean} \textendash{} Expected mean value

\item[{Return type}] \leavevmode
{[}1 x N\_out{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pdf() (pygpc.EGPC.EGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pdf}}}{\emph{coeffs}, \emph{n\_samples}, \emph{output\_idx=None}}{}
Determine the estimated pdfs of the output quantities

pdf\_x, pdf\_y = EGPC.get\_pdf(coeffs, N\_samples, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Gpc coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples used to estimate output pdf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Index of output quantities to consider.
If output\_idx=None, all output quantities are considered

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{pdf\_x} (\sphinxstyleemphasis{{[}100 x N\_out{]} np.ndarray}) \textendash{} x-coordinates of output pdf (output quantity),

\item {} 
\sphinxstylestrong{pdf\_y} (\sphinxstyleemphasis{{[}100 x N\_out{]} np.ndarray}) \textendash{} y-coordinates of output pdf (probability density of output quantity)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_samples() (pygpc.EGPC.EGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_samples}}}{\emph{self}, \emph{coeffs=None}, \emph{n\_samples=100}, \emph{output\_idx=None}}{}
Randomly sample the gPC expansion to determine output pdfs in specific points.

xi = EGPC.get\_pdf\_mc(N\_samples, coeffs=None, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} gPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random samples drawn from the respective input pdfs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Index of output quantities to consider.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{xi} (\sphinxstyleemphasis{{[}N\_samples x dim{]} np.ndarray}) \textendash{} Generated samples in normalized coordinates.

\item {} 
\sphinxstylestrong{pce} (\sphinxstyleemphasis{{[}N\_samples x N\_out{]} np.ndarray}) \textendash{} GPC approximation at points xi.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sobol\_composition() (pygpc.EGPC.EGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_sobol_composition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sobol\_composition}}}{\emph{sobol=None}, \emph{sobol\_idx=None}, \emph{sobol\_idx\_bool=None}}{}
Determine average ratios of Sobol indices over all output quantities:
(i) over all orders and (e.g. 1st: 90\%, 2nd: 8\%, 3rd: 2\%)
(ii) for the 1st order indices w.r.t. each random variable. (1st: x1: 50\%, x2: 40\%)

sobol, sobol\_idx, sobol\_rel\_order\_mean, sobol\_rel\_order\_std, sobol\_rel\_1st\_order\_mean, sobol\_rel\_1st\_order\_std
= EGPC.get\_sobol\_composition(coeffs=None, sobol=None, sobol\_idx=None, sobol\_idx\_bool=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_sobol x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Unnormalized sobol\_indices

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_sobol x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameter combinations in rows of sobol.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_idx\_bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of np.ndarray of bool}}) \textendash{} Boolean mask that determines which multi indices are unique.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sobol\_rel\_order\_mean} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,),
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_order\_std} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Standard deviation of the proportion of the Sobol indices of the different order to the total variance
(1st, 2nd, etc..,), (over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_1st\_order\_mean} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Average proportion of the random variables of the 1st order Sobol indices to the total variance,
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_1st\_order\_std} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Standard deviation of the proportion of the random variables of the 1st order Sobol indices to the total
variance
(over all output quantities)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sobol\_indices() (pygpc.EGPC.EGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_sobol_indices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_sobol\_indices}}}{\emph{self}, \emph{coeffs=None}}{}
Calculate the available sobol indices.

sobol, sobol\_idx = EGPC.get\_sobol\_indices(coeffs=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Gpc coefficients

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sobol} (\sphinxstyleemphasis{{[}N\_sobol x N\_out{]} np.ndarray}) \textendash{} Unnormalized sobol\_indices

\item {} 
\sphinxstylestrong{sobol\_idx} (\sphinxstyleemphasis{list of {[}N\_sobol x dim{]} np.ndarray}) \textendash{} Parameter combinations in rows of sobol.

\item {} 
\sphinxstylestrong{sobol\_idx\_bool} (\sphinxstyleemphasis{list of np.ndarray of bool}) \textendash{} Boolean mask that determines which multi indices are unique.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_standard\_deviation() (pygpc.EGPC.EGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.EGPC.EGPC.get_standard_deviation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_standard\_deviation}}}{\emph{coeffs}}{}
Calculate the standard deviation.

std = EGPC.get\_standard\_deviation(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_coeffs x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Gpc coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{std} \textendash{} Standard deviation

\item[{Return type}] \leavevmode
{[}1 x N\_out{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.GPC module}
\label{\detokenize{pygpc:module-pygpc.GPC}}\label{\detokenize{pygpc:pygpc-gpc-module}}\index{pygpc.GPC (module)}\index{GPC (class in pygpc.GPC)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.GPC.}}\sphinxbfcode{\sphinxupquote{GPC}}}{\emph{problem}, \emph{fn\_results}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

General gPC base class
\index{problem (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.problem}}\pysigline{\sphinxbfcode{\sphinxupquote{problem}}}
GPC Problem under investigation
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Problem class instance

\end{description}\end{quote}

\end{fulllineitems}

\index{basis (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.basis}}\pysigline{\sphinxbfcode{\sphinxupquote{basis}}}
Basis of the gPC including BasisFunctions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Basis class instance

\end{description}\end{quote}

\end{fulllineitems}

\index{grid (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.grid}}\pysigline{\sphinxbfcode{\sphinxupquote{grid}}}
Grid of the derived gPC approximation
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Grid class instance

\end{description}\end{quote}

\end{fulllineitems}

\index{gpc\_matrix (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.gpc_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{gpc\_matrix}}}
generalized polynomial chaos matrix
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}N\_samples x N\_poly{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{gpc\_matrix\_inv (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.gpc_matrix_inv}}\pysigline{\sphinxbfcode{\sphinxupquote{gpc\_matrix\_inv}}}
pseudo inverse of the generalized polynomial chaos matrix
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}N\_poly x N\_samples{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{nan\_elm (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.nan_elm}}\pysigline{\sphinxbfcode{\sphinxupquote{nan\_elm}}}
Indices of NaN elements of model output
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ndarray of int

\end{description}\end{quote}

\end{fulllineitems}

\index{gpc\_matrix\_coords\_id (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.gpc_matrix_coords_id}}\pysigline{\sphinxbfcode{\sphinxupquote{gpc\_matrix\_coords\_id}}}
UUID4() IDs of grid points the gPC matrix derived with
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of UUID4()

\end{description}\end{quote}

\end{fulllineitems}

\index{gpc\_matrix\_b\_id (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.gpc_matrix_b_id}}\pysigline{\sphinxbfcode{\sphinxupquote{gpc\_matrix\_b\_id}}}
UUID4() IDs of basis functions the gPC matrix derived with
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of UUID4()

\end{description}\end{quote}

\end{fulllineitems}

\index{solver (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.solver}}\pysigline{\sphinxbfcode{\sphinxupquote{solver}}}
Default solver to determine the gPC coefficients (can be chosen during GPC.solve)
- ‘Moore-Penrose’ … Pseudoinverse of gPC matrix (SGPC.Reg, EGPC)
- ‘OMP’ … Orthogonal Matching Pursuit, sparse recovery approach (SGPC.Reg, EGPC)
- ‘NumInt’ … Numerical integration, spectral projection (SGPC.Quad)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{gpu (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.gpu}}\pysigline{\sphinxbfcode{\sphinxupquote{gpu}}}
Flag to execute the calculation on the gpu
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{verbose (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.verbose}}\pysigline{\sphinxbfcode{\sphinxupquote{verbose}}}
boolean value to determine if to print out the progress into the standard output
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{fn\_results (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.fn_results}}\pysigline{\sphinxbfcode{\sphinxupquote{fn\_results}}}
If provided, model evaluations are saved in fn\_results.hdf5 file and gpc object in fn\_results.pkl file
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string, optional, default=None

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_cpu (pygpc.GPC.GPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.n_cpu}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_cpu}}}
Number of threads to use for parallel evaluation of the model function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, optional, default=1

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_gpc\_matrix() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.calc_gpc_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_gpc\_matrix}}}{\emph{b}, \emph{x}, \emph{verbose=False}}{}
Construct the gPC matrix.

gpc\_matrix = calc\_gpc\_matrix(b, x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of BasisFunction object instances}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter wise basis function objects used in gPC (Basis.b)
Multiplying all elements in a row at location xi = (x1, x2, …, x\_dim) yields the global basis function.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x x n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Coordinates of x = (x1, x2, …, x\_dim) where the rows of the gPC matrix are evaluated (normalized {[}-1, 1{]})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} boolean value to determine if to print out the progress into the standard output

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{gpc\_matrix} \textendash{} GPC matrix where the columns correspond to the basis functions and the rows the to the sample coordinates

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x x n\_basis{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_approximation() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.get_approximation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_approximation}}}{\emph{coeffs}, \emph{x}, \emph{output\_idx=None}}{}
Calculates the gPC approximation in points with output\_idx and normalized parameters xi (interval: {[}-1, 1{]}).

pce = GPC.get\_approximation(coeffs, x, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients for each output variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x x n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Coordinates of x = (x1, x2, …, x\_dim) where the rows of the gPC matrix are evaluated (normalized {[}-1, 1{]})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index of output quantities to consider (Default: all).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pce} \textendash{} GPC approximation at normalized coordinates x.

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pdf() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.get_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pdf}}}{\emph{coeffs}, \emph{n\_samples}, \emph{output\_idx=None}}{}
Determine the estimated pdfs of the output quantities

pdf\_x, pdf\_y = SGPC.get\_pdf(coeffs, n\_samples, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_coeffs x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples used to estimate output pdfs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index of output quantities to consider (if output\_idx=None, all output quantities are considered)

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{pdf\_x} (\sphinxstyleemphasis{ndarray of float {[}100 x n\_out{]}}) \textendash{} x-coordinates of output pdfs of output quantities

\item {} 
\sphinxstylestrong{pdf\_y} (\sphinxstyleemphasis{ndarray of float {[}100 x n\_out{]}}) \textendash{} y-coordinates of output pdfs (probability density of output quantity)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_samples() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.get_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_samples}}}{\emph{coeffs}, \emph{n\_samples}, \emph{output\_idx=None}}{}
Randomly sample gPC expansion.

x, pce = SGPC.get\_pdf\_mc(n\_samples, coeffs, output\_idx=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random samples drawn from the respective input pdfs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Index of output quantities to consider.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{x} (\sphinxstyleemphasis{ndarray of float {[}n\_samples x dim{]}}) \textendash{} Generated samples in normalized coordinates {[}-1, 1{]}.

\item {} 
\sphinxstylestrong{pce} (\sphinxstyleemphasis{ndarray of float {[}n\_samples x n\_out{]}}) \textendash{} GPC approximation at points x.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{init\_gpc\_matrix() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.init_gpc_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_gpc\_matrix}}}{}{}
Sets self.gpc\_matrix with given self.basis and self.grid

\end{fulllineitems}

\index{replace\_gpc\_matrix\_samples() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.replace_gpc_matrix_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replace\_gpc\_matrix\_samples}}}{\emph{idx}, \emph{seed=None}}{}
Replace distinct sample points from the gPC matrix with new ones.

GPC.replace\_gpc\_matrix\_samples(idx, seed=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_samples}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Array of grid indices of grid.coords{[}idx, :{]} which are going to be replaced
(rows of gPC matrix will be replaced by new ones)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{seed}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Random seeding point

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_gpc\_matrix\_hdf5() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.save_gpc_matrix_hdf5}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_gpc\_matrix\_hdf5}}}{}{}
Save gPC matrix in .hdf5 file \textless{}”fn\_results” + “.hdf5”\textgreater{} under the key “gpc\_matrix”.
If a gpc matrix is already present, check for equality and save only appended rows and columns

\end{fulllineitems}

\index{solve() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{sim\_results}, \emph{solver=None}, \emph{settings=None}, \emph{gpc\_matrix=None}, \emph{verbose=False}}{}
Determines gPC coefficients
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sim\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_grid x N\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray of float}}) \textendash{} results from simulations with N\_out output quantities

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Solver to determine the gPC coefficients
- ‘Moore-Penrose’ … Pseudoinverse of gPC matrix (SGPC.Reg, EGPC)
- ‘OMP’ … Orthogonal Matching Pursuit, sparse recovery approach (SGPC.Reg, EGPC)
- ‘NumInt’ … Numerical integration, spectral projection (SGPC.Quad)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Solver settings
- ‘Moore-Penrose’ … None
- ‘OMP’ … \{“n\_coeffs\_sparse”: int\} Number of gPC coefficients != 0 or “sparsity”: float 0…1
- ‘NumInt’ … None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpc\_matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid x n\_basis}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default: self.gpc\_matrix}}) \textendash{} GPC matrix to invert

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} boolean value to determine if to print out the progress into the standard output

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{coeffs} \textendash{} gPC coefficients

\item[{Return type}] \leavevmode
ndarray of float {[}n\_coeffs x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_gpc\_matrix() (pygpc.GPC.GPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.GPC.GPC.update_gpc_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_gpc\_matrix}}}{}{}
Update gPC matrix according to existing self.grid and self.basis.

Call this method when self.gpc\_matrix does not fit to self.grid and self.basis objects anymore
The old gPC matrix with their self.gpc\_matrix\_b\_id and self.gpc\_matrix\_coords\_id is compared
to self.basis.b\_id and self.grid.coords\_id. New rows and columns are computed when differences are found.

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.Grid module}
\label{\detokenize{pygpc:module-pygpc.Grid}}\label{\detokenize{pygpc:pygpc-grid-module}}\index{pygpc.Grid (module)}
Functions and classes that provide data and methods for the generation and processing of numerical grids
\index{Grid (class in pygpc.Grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Grid.}}\sphinxbfcode{\sphinxupquote{Grid}}}{\emph{parameters\_random}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Grid class
\index{parameters\_random (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.parameters_random}}\pysigline{\sphinxbfcode{\sphinxupquote{parameters\_random}}}
OrderedDict containing the RandomParameter instances the grids are generated for
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
OrderedDict of RandomParameter instances

\end{description}\end{quote}

\end{fulllineitems}

\index{\_weights (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid._weights}}\pysigline{\sphinxbfcode{\sphinxupquote{\_weights}}}
Weights of the grid (all)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ndarray of float {[}n\_grid x dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_coords (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid._coords}}\pysigline{\sphinxbfcode{\sphinxupquote{\_coords}}}
Denormalized coordinates xi
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ndarray of float {[}n\_grid x dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_coords\_norm (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid._coords_norm}}\pysigline{\sphinxbfcode{\sphinxupquote{\_coords\_norm}}}
Normalized {[}-1, 1{]} coordinates xi
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
nd array of float {[}n\_grid x dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{coords\_id (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.coords_id}}\pysigline{\sphinxbfcode{\sphinxupquote{coords\_id}}}
Unique IDs of grid points
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of UUID objects (version 4) {[}n\_grid{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_grid (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.n_grid}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_grid}}}
Total number of nodes in grid.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{coords (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.coords}}\pysigline{\sphinxbfcode{\sphinxupquote{coords}}}
\end{fulllineitems}

\index{coords\_norm (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.coords_norm}}\pysigline{\sphinxbfcode{\sphinxupquote{coords\_norm}}}
\end{fulllineitems}

\index{get\_denormalized\_coordinates() (pygpc.Grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_denormalized_coordinates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_denormalized\_coordinates}}}{\emph{coords\_norm}}{}
Denormalize grid from standardized ({[}-1, 1{]} except hermite) to original parameter space for simulations.

coords = Grid.get\_denormalized\_coordinates(coords\_norm)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_samples x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} normalized {[}-1, 1{]} coordinates xi

\item[{Returns}] \leavevmode
\sphinxstylestrong{coords} \textendash{} Denormalized coordinates xi

\item[{Return type}] \leavevmode
{[}N\_samples x dim{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_normalized\_coordinates() (pygpc.Grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_normalized_coordinates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_normalized\_coordinates}}}{\emph{coords}}{}
Normalize grid from original parameter (except hermite) to standardized ({[}-1, 1{]} space for simulations.

coords\_norm = Grid.get\_normalized\_coordinates(coords)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_samples x dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Denormalized coordinates xi in original parameter space

\item[{Returns}] \leavevmode
\sphinxstylestrong{coords\_norm} \textendash{} Normalized {[}-1, 1{]} coordinates xi

\item[{Return type}] \leavevmode
{[}N\_samples x dim{]} np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_quadrature\_clenshaw\_curtis\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_clenshaw_curtis_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_clenshaw\_curtis\_1d}}}{\emph{n}}{}
Get the Clenshaw Curtis nodes and weights.

knots, weights = Grid.get\_quadrature\_clenshaw\_curtis\_1d(n)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of knots

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Weights of the grid

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_quadrature\_fejer1\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_fejer1_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_fejer1\_1d}}}{\emph{n}}{}
Computes the Fejer type 1 nodes and weights.

This method uses a direct approach after Davis and Rabinowitz (2007) {[}1{]} and Gautschi (1967) {[}2{]}.
The paper by Waldvogel (2006) {[}3{]} exhibits a more efficient approach using Fourier transforms.

knots, weights = Grid.get\_quadrature\_fejer1\_1d(n)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of knots

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{ndarray}) \textendash{} Knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{ndarray}) \textendash{} Weights of the grid

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{get\_quadrature\_fejer2\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_fejer2_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_fejer2\_1d}}}{\emph{n}}{}
Computes the Fejer type 2 nodes and weights (Clenshaw Curtis without boundary nodes).

This method uses a direct approach after Davis and Rabinowitz (2007) {[}1{]} and Gautschi (1967) {[}2{]}.
The paper by Waldvogel (2006) {[}3{]} exhibits a more efficient approach using Fourier transforms.

knots, weights = Grid.get\_quadrature\_fejer2\_1d(n)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of knots

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Weights of the grid

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{get\_quadrature\_hermite\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_hermite_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_hermite\_1d}}}{\emph{n}}{}
Get knots and weights of Hermite polynomials (normal distribution).

knots, weights = Grid.get\_quadrature\_hermite\_1d(n)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of knots

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{np.ndarray}) \textendash{} knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{np.ndarray}) \textendash{} weights of the grid

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_quadrature\_jacobi\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_jacobi_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_jacobi\_1d}}}{\emph{n}, \emph{p}, \emph{q}}{}
Get knots and weights of Jacobi polynomials.

knots, weights = Grid.get\_quadrature\_jacobi\_1d(n, p, q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of knots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} First shape parameter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Second shape parameter

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Weights of the grid

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_quadrature\_patterson\_1d() (pygpc.Grid.Grid static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.get_quadrature_patterson_1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_quadrature\_patterson\_1d}}}{\emph{n}}{}
Computes the nested Gauss-Patterson nodes and weights for n = 1,3,7,15,31 nodes.

knots, weights = Grid.get\_quadrature\_patterson\_1d(n)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of knots (possible values: 1, 3, 7, 15, 31)

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{knots} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Knots of the grid

\item {} 
\sphinxstylestrong{weights} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Weights of the grid

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{weights (pygpc.Grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.Grid.weights}}\pysigline{\sphinxbfcode{\sphinxupquote{weights}}}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomGrid (class in pygpc.Grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.RandomGrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Grid.}}\sphinxbfcode{\sphinxupquote{RandomGrid}}}{\emph{parameters\_random}, \emph{options}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Grid.Grid}}}}}

RandomGrid object

RandomGrid(parameters\_random, options)
\index{n\_grid (pygpc.Grid.RandomGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.RandomGrid.n_grid}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_grid}}}
Number of random samples to generate
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{seed (pygpc.Grid.RandomGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.RandomGrid.seed}}\pysigline{\sphinxbfcode{\sphinxupquote{seed}}}
Seeding point to replicate random grids
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{extend\_random\_grid() (pygpc.Grid.RandomGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.RandomGrid.extend_random_grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend\_random\_grid}}}{\emph{n\_grid\_new}, \emph{seed=None}}{}
Add sample points according to input pdfs to grid (old points are kept).

extend\_random\_grid(n\_grid\_new, seed=None):
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_grid\_new}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Total number of grid points in extended random grid (old points are kept)
(n\_grid\_add = n\_grid\_new - n\_grid\_old)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{seed}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Random seeding point

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SparseGrid (class in pygpc.Grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Grid.}}\sphinxbfcode{\sphinxupquote{SparseGrid}}}{\emph{parameters\_random}, \emph{options}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Grid.Grid}}}}}

SparseGrid object instance.

Grid.SparseGrid(parameters\_random, options)
\index{grid\_type (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.grid_type}}\pysigline{\sphinxbfcode{\sphinxupquote{grid\_type}}}
specify type of quadrature used to construct sparse grid (‘jacobi’, ‘hermite’, ‘cc’, ‘fejer2’)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}N\_vars{]} list of str

\end{description}\end{quote}

\end{fulllineitems}

\index{level (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.level}}\pysigline{\sphinxbfcode{\sphinxupquote{level}}}
number of levels in each dimension
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}N\_vars{]} list of int

\end{description}\end{quote}

\end{fulllineitems}

\index{level\_max (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.level_max}}\pysigline{\sphinxbfcode{\sphinxupquote{level\_max}}}
global combined level maximum
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{level\_sequence (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.level_sequence}}\pysigline{\sphinxbfcode{\sphinxupquote{level\_sequence}}}
list containing the levels
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of int

\end{description}\end{quote}

\end{fulllineitems}

\index{interaction\_order (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.interaction_order}}\pysigline{\sphinxbfcode{\sphinxupquote{interaction\_order}}}
interaction order of parameters and grid, i.e. the grid points are lying between this number of dimensions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{order\_sequence\_type (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.order_sequence_type}}\pysigline{\sphinxbfcode{\sphinxupquote{order\_sequence\_type}}}
type of order sequence (‘lin’, ‘exp’) common: ‘exp’
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{order\_sequence (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.order_sequence}}\pysigline{\sphinxbfcode{\sphinxupquote{order\_sequence}}}
list containing the polynomial order of the levels
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of int

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_grid (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.make_grid}}\pysigline{\sphinxbfcode{\sphinxupquote{make\_grid}}}
boolean value to determine if to generate grid during initialization
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{verbose (pygpc.Grid.SparseGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.verbose}}\pysigline{\sphinxbfcode{\sphinxupquote{verbose}}}
boolean value to determine if to print out the progress into the standard output
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_coords\_weights() (pygpc.Grid.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.calc_coords_weights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_coords\_weights}}}{}{}
Determine coords and weights of sparse grid by generating, merging and subtracting sub-grids.

\end{fulllineitems}

\index{calc\_grid() (pygpc.Grid.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.calc_grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_grid}}}{}{}
Calculate a cubature lookup table for knots and weights.

dl\_k, dl\_w = calc\_grid()
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{dl\_k} (\sphinxstyleemphasis{list of list of float}) \textendash{} Cubature lookup table for knots

\item {} 
\sphinxstylestrong{dl\_w} (\sphinxstyleemphasis{list of list of float}) \textendash{} Cubature lookup table for weights

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_l\_level() (pygpc.Grid.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.calc_l_level}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_l\_level}}}{}{}
Calculate the l-level needed for the Fejer grid type 2.

l\_level = calc\_l\_level()
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{l\_level} \textendash{} Multi indices filtered by level capacity and interaction order

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_multi\_indices() (pygpc.Grid.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.calc_multi_indices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_multi\_indices}}}{}{}
Calculate the multi index list needed for the calculation of the SparseGrid.

\end{fulllineitems}

\index{calc\_tensor\_products() (pygpc.Grid.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.SparseGrid.calc_tensor_products}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_tensor\_products}}}{}{}
Calculate the tensor products of the knots and the weights.

dll\_k, dll\_w = calc\_tensor\_products()
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{dll\_k} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Tensor product of knots

\item {} 
\sphinxstylestrong{dll\_w} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Tensor product of weights

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TensorGrid (class in pygpc.Grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.TensorGrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Grid.}}\sphinxbfcode{\sphinxupquote{TensorGrid}}}{\emph{parameters\_random}, \emph{options}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Grid.Grid}}}}}

Generate TensorGrid object instance.

TensorGrid(random\_parameters, parameters):
\index{grid\_type (pygpc.Grid.TensorGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.TensorGrid.grid_type}}\pysigline{\sphinxbfcode{\sphinxupquote{grid\_type}}}
Type of quadrature used to construct tensor grid (‘jacobi’, ‘hermite’, ‘clenshaw\_curtis’, ‘fejer2’)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}N\_vars{]} list of str

\end{description}\end{quote}

\end{fulllineitems}

\index{knots\_dim\_list (pygpc.Grid.TensorGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.TensorGrid.knots_dim_list}}\pysigline{\sphinxbfcode{\sphinxupquote{knots\_dim\_list}}}
Knots of grid in each dimension
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}dim{]} list of np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{weights\_dim\_list (pygpc.Grid.TensorGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Grid.TensorGrid.weights_dim_list}}\pysigline{\sphinxbfcode{\sphinxupquote{weights\_dim\_list}}}
Weights of grid in each dimension
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{[}dim{]} list of np.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.Problem module}
\label{\detokenize{pygpc:module-pygpc.Problem}}\label{\detokenize{pygpc:pygpc-problem-module}}\index{pygpc.Problem (module)}\index{Problem (class in pygpc.Problem)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Problem.Problem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Problem.}}\sphinxbfcode{\sphinxupquote{Problem}}}{\emph{model}, \emph{parameters}}{}
Data wrapper for the gpc problem containing the model to investigate and the associated parameters.
\subsubsection*{Notes}

Add Attributes:
\begin{description}
\item[{random\_vars: {[}dim{]} list of str}] \leavevmode
String labels of the random variables

\item[{N\_out: int}] \leavevmode
Number of output coefficients

\item[{dim: int}] \leavevmode
Number of uncertain parameters to process

\item[{pdf\_type: {[}dim{]} list of str}] \leavevmode
Type of pdf ‘beta’ or ‘norm’

\item[{pdf\_shape: list of list of float}] \leavevmode
Shape parameters of pdfs
beta-dist:   {[}{[}{]}, … {[}alpha, beta{]}, …, {[}{]}{]}
normal-dist: {[}{[}{]}, … {[}mean, std{]}, …, {[}{]}{]}

\item[{pdf\_limits: list of list of float}] \leavevmode
upper and lower bounds of random variables
beta-dist:   {[}{[}{]}, … {[}min, max{]}, …, {[}{]}{]}
normal-dist: {[}{[}{]}, … {[}0, 0{]}, …, {[}{]}{]} (not used)

\end{description}
\subsubsection*{Examples}

Setup model and specify parameters of gPC problem

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pygpc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{OrderedDict}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Define model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{testfunctions}\PYG{o}{.}\PYG{n}{SphereModel}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Define Problem}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters} \PYG{o}{=} \PYG{n}{OrderedDict}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} we must use an ordered dict form the start, otherwise the order will be mixed}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}                                                 \PYG{c+c1}{\PYGZsh{} constant parameter}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi\PYGZus{}electrode}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{15}                                                \PYG{c+c1}{\PYGZsh{}       \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{N\PYGZus{}points}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{201}                                                    \PYG{c+c1}{\PYGZsh{}       \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sigma\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{RandomParameter}\PYG{o}{.}\PYG{n}{Beta}\PYG{p}{(}\PYG{n}{pdf\PYGZus{}shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pdf\PYGZus{}limits}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+m+mf}{0.45}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} random variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sigma\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{RandomParameter}\PYG{o}{.}\PYG{n}{Beta}\PYG{p}{(}\PYG{n}{pdf\PYGZus{}shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pdf\PYGZus{}limits}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{0.02}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}       \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sigma\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{RandomParameter}\PYG{o}{.}\PYG{n}{Norm}\PYG{p}{(}\PYG{n}{pdf\PYGZus{}shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{}       \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{Problem}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}
\end{sphinxVerbatim}
\index{validate() (pygpc.Problem.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Problem.Problem.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{}{}
Verifies the problem, by testing if the parameters including the random variables are defined appropriate.
In cases, the model may not run correctly for some parameter combinations, the user may change the definition
of the random parameters or the constants in model.validate.

calls model.validate

overwrites parameters

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.RandomParameter module}
\label{\detokenize{pygpc:module-pygpc.RandomParameter}}\label{\detokenize{pygpc:pygpc-randomparameter-module}}\index{pygpc.RandomParameter (module)}\index{Beta (class in pygpc.RandomParameter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Beta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.RandomParameter.}}\sphinxbfcode{\sphinxupquote{Beta}}}{\emph{pdf\_shape}, \emph{pdf\_limits}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.RandomParameter.RandomParameter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.RandomParameter.RandomParameter}}}}}

Beta distributed random variable sub-class

Probability density function:
\index{init\_basis\_function() (pygpc.RandomParameter.Beta method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Beta.init_basis_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_basis\_function}}}{\emph{order}}{}
Initializes Jacobi BasisFunction of Beta RandomParameter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Order of basis function

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf() (pygpc.RandomParameter.Beta method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Beta.pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{x}}{}
Calculate the probability density function of the beta distributed random variable.

pdf = Beta.pdf(x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Values of random variable

\item[{Returns}] \leavevmode
\sphinxstylestrong{pdf} \textendash{} Probability density at values x

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf\_norm() (pygpc.RandomParameter.Beta method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Beta.pdf_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf\_norm}}}{\emph{x}}{}
Calculate the probability density function of the normalized beta distributed random variable in interval
{[}-1, 1{]}.

pdf = Beta.pdf\_norm(x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Values of random variable

\item[{Returns}] \leavevmode
\sphinxstylestrong{pdf} \textendash{} Probability density at values x

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Norm (class in pygpc.RandomParameter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.RandomParameter.}}\sphinxbfcode{\sphinxupquote{Norm}}}{\emph{pdf\_shape}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.RandomParameter.RandomParameter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.RandomParameter.RandomParameter}}}}}

Normal distributed random variable sub-class

Probability density function
\begin{equation*}
\begin{split}pdf = \frac{1}{\sqrt{2\pi\sigma^2}}\exp{-\frac{(x-\mu)^2}{2\sigma^2}}\end{split}
\end{equation*}\index{init\_basis\_function() (pygpc.RandomParameter.Norm static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Norm.init_basis_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{init\_basis\_function}}}{\emph{order}}{}
Initializes Hermite BasisFunction of Norm RandomParameter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Order of basis function

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf() (pygpc.RandomParameter.Norm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Norm.pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{x}}{}
Calculate the probability density function of the normal distributed random variable.

pdf = Norm.pdf(x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Values of random variable

\item[{Returns}] \leavevmode
\sphinxstylestrong{pdf} \textendash{} Probability density

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf\_norm() (pygpc.RandomParameter.Norm static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.Norm.pdf_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{pdf\_norm}}}{\emph{x}}{}
Calculate the probability density function of the normalized normal distributed random variable
(zero mean, std 1).

pdf = Norm.pdf\_norm(x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Values of random variable

\item[{Returns}] \leavevmode
\sphinxstylestrong{pdf} \textendash{} Probability density

\item[{Return type}] \leavevmode
ndarray of float {[}n\_x{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RandomParameter (class in pygpc.RandomParameter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.RandomParameter.}}\sphinxbfcode{\sphinxupquote{RandomParameter}}}{\emph{pdf\_type=None}, \emph{pdf\_shape=None}, \emph{pdf\_limits=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

RandomParameter class
\index{pdf\_type (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.pdf_type}}\pysigline{\sphinxbfcode{\sphinxupquote{pdf\_type}}}
Distribution type of random variable (‘beta’, ‘norm’)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf\_shape (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.pdf_shape}}\pysigline{\sphinxbfcode{\sphinxupquote{pdf\_shape}}}
Shape parameters of beta distributed random variable {[}p, q{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of float {[}2{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf\_limits (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.pdf_limits}}\pysigline{\sphinxbfcode{\sphinxupquote{pdf\_limits}}}
Lower and upper bounds of random variable {[}min, max{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of float {[}2{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{mean (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.mean}}\pysigline{\sphinxbfcode{\sphinxupquote{mean}}}
Mean value
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{std (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.std}}\pysigline{\sphinxbfcode{\sphinxupquote{std}}}
Standard deviation
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{var (pygpc.RandomParameter.RandomParameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.RandomParameter.RandomParameter.var}}\pysigline{\sphinxbfcode{\sphinxupquote{var}}}
Variance
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.SGPC module}
\label{\detokenize{pygpc:module-pygpc.SGPC}}\label{\detokenize{pygpc:pygpc-sgpc-module}}\index{pygpc.SGPC (module)}\index{Quad (class in pygpc.SGPC)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Quad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.SGPC.}}\sphinxbfcode{\sphinxupquote{Quad}}}{\emph{problem}, \emph{order}, \emph{order\_max}, \emph{order\_max\_norm}, \emph{interaction\_order}, \emph{fn\_results=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.SGPC.SGPC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.SGPC.SGPC}}}}}

Quadrature SGPC sub-class

\end{fulllineitems}

\index{Reg (class in pygpc.SGPC)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Reg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.SGPC.}}\sphinxbfcode{\sphinxupquote{Reg}}}{\emph{problem}, \emph{order}, \emph{order\_max}, \emph{order\_max\_norm}, \emph{interaction\_order}, \emph{fn\_results=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.SGPC.SGPC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.SGPC.SGPC}}}}}

Regression gPC subclass

Reg(problem, order, order\_max, interaction\_order, fn\_results=None)
\index{relative\_error\_loocv (pygpc.SGPC.Reg attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Reg.relative_error_loocv}}\pysigline{\sphinxbfcode{\sphinxupquote{relative\_error\_loocv}}}
relative error of the leave-one-out-cross-validation
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of float

\end{description}\end{quote}

\end{fulllineitems}

\index{solver (pygpc.SGPC.Reg attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Reg.solver}}\pysigline{\sphinxbfcode{\sphinxupquote{solver}}}
Solver to determine the gPC coefficients
- ‘Moore-Penrose’ … Pseudoinverse of gPC matrix (SGPC.Reg, EGPC)
- ‘OMP’ … Orthogonal Matching Pursuit, sparse recovery approach (SGPC.Reg, EGPC)
- ‘NumInt’ … Numerical integration, spectral projection (SGPC.Quad)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{settings (pygpc.SGPC.Reg attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Reg.settings}}\pysigline{\sphinxbfcode{\sphinxupquote{settings}}}
Solver settings
- ‘Moore-Penrose’ … None
- ‘OMP’ … \{“n\_coeffs\_sparse”: int\} Number of gPC coefficients != 0
- ‘NumInt’ … None
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{loocv() (pygpc.SGPC.Reg method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.Reg.loocv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{loocv}}}{\emph{sim\_results}, \emph{coeffs}}{}
Perform leave-one-out cross validation of gPC approximation and add error value to self.relative\_error\_loocv.
The loocv error is calculated analytically after eq. (35) in {[}1{]} but omitting the “1 - ” term, i.e. it
corresponds to 1 - Q\textasciicircum{}2.

relative\_error\_loocv = SGPC.loocv(sim\_results, coeffs)
\begin{equation*}
\begin{split}\epsilon_{LOOCV} = \frac{\frac{1}{N}\sum_{i=1}^N \left( \frac{y(\xi_i) - \hat{y}(\xi_i)}{1-h_i} \right)^2}{\frac{1}{N-1}\sum_{i=1}^N \left( y(\xi_i) - \bar{y} \right)^2}\end{split}
\end{equation*}
with
\begin{equation*}
\begin{split}\mathbf{h} = \mathrm{diag}(\mathbf{\Psi} (\mathbf{\Psi}^T \mathbf{\Psi})^{-1} \mathbf{\Psi}^T)\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sim\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Results from n\_grid simulations with n\_out output quantities

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{relative\_error\_loocv} \textendash{} Relative mean error of leave one out cross validation

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}


\end{fulllineitems}

\index{SGPC (class in pygpc.SGPC)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.SGPC.}}\sphinxbfcode{\sphinxupquote{SGPC}}}{\emph{problem}, \emph{order}, \emph{order\_max}, \emph{order\_max\_norm}, \emph{interaction\_order}, \emph{fn\_results=None}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.GPC.GPC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.GPC.GPC}}}}}

Sub-class for standard gPC (SGPC)
\index{order (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.order}}\pysigline{\sphinxbfcode{\sphinxupquote{order}}}
Maximum individual expansion order {[}order\_1, order\_2, …, order\_dim{]}.
Generates individual polynomials also if maximum expansion order in order\_max is exceeded
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of int {[}dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{order\_max (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.order_max}}\pysigline{\sphinxbfcode{\sphinxupquote{order\_max}}}
Maximum global expansion order.
The maximum expansion order considers the sum of the orders of combined polynomials together with the
chosen norm “order\_max\_norm”. Typically this norm is 1 such that the maximum order is the sum of all
monomial orders.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{order\_max\_norm (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.order_max_norm}}\pysigline{\sphinxbfcode{\sphinxupquote{order\_max\_norm}}}
Norm for which the maximum global expansion order is defined {[}0, 1{]}. Values \textless{} 1 decrease the total number
of polynomials in the expansion such that interaction terms are penalized more. This truncation scheme
is also referred to “hyperbolic polynomial chaos expansion” such that sum(a\_i\textasciicircum{}q)\textasciicircum{}1/q \textless{}= p,
where p is order\_max and q is order\_max\_norm (for more details see eq. (27) in {[}1{]}).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{interaction\_order (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.interaction_order}}\pysigline{\sphinxbfcode{\sphinxupquote{interaction\_order}}}
Number of random variables, which can interact with each other.
All polynomials are ignored, which have an interaction order greater than the specified
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{interaction\_order\_current (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.interaction_order_current}}\pysigline{\sphinxbfcode{\sphinxupquote{interaction\_order\_current}}}
Number of random variables, which can interact with each other.
All polynomials are ignored, which have an interaction order greater than the specified
Current interaction order counter (only used in case of adaptive algorithms)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{fn\_results (pygpc.SGPC.SGPC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.fn_results}}\pysigline{\sphinxbfcode{\sphinxupquote{fn\_results}}}
If provided, model evaluations are saved in fn\_results.hdf5 file and gpc object in fn\_results.pkl file
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string, optional, default=None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_extracted\_sobol\_order() (pygpc.SGPC.SGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_extracted_sobol_order}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_extracted\_sobol\_order}}}{\emph{sobol}, \emph{sobol\_idx\_bool}, \emph{order=1}}{}
Extract Sobol indices with specified order from Sobol data.

sobol\_1st, sobol\_idx\_1st = SGPC.get\_extracted\_sobol\_order(sobol, sobol\_idx, order=1)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sobol x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Sobol indices of n\_out output quantities

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_idx\_bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of ndarray of bool}}) \textendash{} Boolean mask which contains unique multi indices.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=1}}) \textendash{} Sobol index order to extract

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sobol\_n\_order} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} n-th order Sobol indices of n\_out output quantities

\item {} 
\sphinxstylestrong{sobol\_idx\_n\_order} (\sphinxstyleemphasis{ndarray of int}) \textendash{} Parameter label indices belonging to n-th order Sobol indices

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_global\_sens() (pygpc.SGPC.SGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_global_sens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_global\_sens}}}{\emph{coeffs}}{}
Determine the global derivative based sensitivity coefficients after Xiu (2009) {[}1{]}.

global\_sens = SGPC.get\_global\_sens(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{global\_sens} \textendash{} Global derivative based sensitivity coefficients

\item[{Return type}] \leavevmode
ndarray {[}dim x n\_out{]}

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{get\_local\_sens() (pygpc.SGPC.SGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_local_sens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_local\_sens}}}{\emph{coeffs}, \emph{x}}{}
Determine the local derivative based sensitivity coefficients in the point of interest x
(normalized coordinates {[}-1, 1{]}).

local\_sens = SGPC.calc\_localsens(coeffs, x)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Point in variable space to evaluate local sensitivity in (normalized coordinates {[}-1, 1{]})

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{local\_sens} \textendash{} Local sensitivity of output quantities in point x

\item[{Return type}] \leavevmode
ndarray {[}dim x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mean() (pygpc.SGPC.SGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_mean}}}{\emph{coeffs}}{}
Calculate the expected mean value.

mean = SGPC.get\_mean(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{mean} \textendash{} Expected value of output quantities

\item[{Return type}] \leavevmode
ndarray of float {[}1 x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sobol\_composition() (pygpc.SGPC.SGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_sobol_composition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sobol\_composition}}}{\emph{sobol}, \emph{sobol\_idx\_bool}}{}
Determine average ratios of Sobol indices over all output quantities:
(i) over all orders and (e.g. 1st: 90\%, 2nd: 8\%, 3rd: 2\%)
(ii) for the 1st order indices w.r.t. each random variable. (1st: x1: 50\%, x2: 40\%)

sobol, sobol\_idx, sobol\_rel\_order\_mean, sobol\_rel\_order\_std, sobol\_rel\_1st\_order\_mean, sobol\_rel\_1st\_order\_std
= SGPC.get\_sobol\_composition(coeffs, sobol, sobol\_idx, sobol\_idx\_bool)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sobol x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unnormalized sobol\_indices

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_idx\_bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of ndarray of bool}}) \textendash{} Boolean mask which contains unique multi indices.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sobol\_rel\_order\_mean} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,),
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_order\_std} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Standard deviation of the proportion of the Sobol indices of the different order to the total variance
(1st, 2nd, etc..,), (over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_1st\_order\_mean} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Average proportion of the random variables of the 1st order Sobol indices to the total variance,
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_1st\_order\_std} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Standard deviation of the proportion of the random variables of the 1st order Sobol indices to the total
variance
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_2nd\_order\_mean} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Average proportion of the random variables of the 2nd order Sobol indices to the total variance,
(over all output quantities)

\item {} 
\sphinxstylestrong{sobol\_rel\_2nd\_order\_std} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Standard deviation of the proportion of the random variables of the 2nd order Sobol indices to the total
variance
(over all output quantities)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sobol\_indices() (pygpc.SGPC.SGPC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_sobol_indices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sobol\_indices}}}{\emph{coeffs}}{}
Calculate the available sobol indices.

sobol, sobol\_idx = SGPC.get\_sobol\_indices(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sobol} (\sphinxstyleemphasis{ndarray of float {[}n\_sobol x n\_out{]}}) \textendash{} Unnormalized Sobol indices

\item {} 
\sphinxstylestrong{sobol\_idx} (\sphinxstyleemphasis{list of ndarray of int {[}n\_sobol x (n\_sobol\_included){]}}) \textendash{} Parameter combinations in rows of sobol.

\item {} 
\sphinxstylestrong{sobol\_idx\_bool} (\sphinxstyleemphasis{ndarray of bool {[}n\_sobol x dim{]}}) \textendash{} Boolean mask which contains unique multi indices.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_standard\_deviation() (pygpc.SGPC.SGPC static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.SGPC.SGPC.get_standard_deviation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_standard\_deviation}}}{\emph{coeffs}}{}
Calculate the standard deviation.

std = SGPC.get\_standard\_deviation(coeffs)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_basis x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item[{Returns}] \leavevmode
\sphinxstylestrong{std} \textendash{} Standard deviation of output quantities

\item[{Return type}] \leavevmode
ndarray of float {[}1 x n\_out{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pygpc.Test module}
\label{\detokenize{pygpc:module-pygpc.Test}}\label{\detokenize{pygpc:pygpc-test-module}}\index{pygpc.Test (module)}\index{Franke (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Franke}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Franke}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Franke test function

\end{fulllineitems}

\index{GFunction (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GFunction}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GFunction test function

\end{fulllineitems}

\index{GenzContinuous (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzContinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzContinuous}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzContinuous test function

\end{fulllineitems}

\index{GenzCornerPeak (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzCornerPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzCornerPeak}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzCornerPeak test function

\end{fulllineitems}

\index{GenzDiscontinuous (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzDiscontinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzDiscontinuous}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzDiscontinuous test function

\end{fulllineitems}

\index{GenzGaussianPeak (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzGaussianPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzGaussianPeak}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzGaussianPeak test function

\end{fulllineitems}

\index{GenzOscillatory (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzOscillatory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzOscillatory}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzOscillatory test function

\end{fulllineitems}

\index{GenzProductPeak (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.GenzProductPeak}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{GenzProductPeak}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

GenzProductPeak test function

\end{fulllineitems}

\index{HyperbolicTangent (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.HyperbolicTangent}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{HyperbolicTangent}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

HyperbolicTangent test function

\end{fulllineitems}

\index{Ishigami (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Ishigami}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Ishigami}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Ishigami test function

\end{fulllineitems}

\index{Lim2002 (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Lim2002}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Lim2002}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Lim2002 test function

\end{fulllineitems}

\index{ManufactureDecay (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.ManufactureDecay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{ManufactureDecay}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

ManufactureDecay test function

\end{fulllineitems}

\index{MovingParticleFrictionForce (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.MovingParticleFrictionForce}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{MovingParticleFrictionForce}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

MovingParticleFrictionForce test function

\end{fulllineitems}

\index{OakleyOhagan2004 (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.OakleyOhagan2004}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{OakleyOhagan2004}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

OakleyOhagan2004 test function

\end{fulllineitems}

\index{Peaks (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Peaks}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Peaks}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Peaks test function

\end{fulllineitems}

\index{Ridge (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Ridge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Ridge}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Ridge test function

\end{fulllineitems}

\index{SphereFun (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.SphereFun}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{SphereFun}}}{\emph{dim=2}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

SphereFun test function

\end{fulllineitems}

\index{SurfaceCoverageSpecies (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.SurfaceCoverageSpecies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{SurfaceCoverageSpecies}}}{\emph{dim}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

SurfaceCoverageSpecies test function

\end{fulllineitems}

\index{Test (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Test}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Test}}}{\emph{dim}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Test function objects

\end{fulllineitems}

\index{Welch1992 (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.Welch1992}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{Welch1992}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

Welch1992 test function

\end{fulllineitems}

\index{WingWeight (class in pygpc.Test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Test.WingWeight}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Test.}}\sphinxbfcode{\sphinxupquote{WingWeight}}}
Bases: {\hyperref[\detokenize{pygpc:pygpc.Test.Test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.Test.Test}}}}}

WingWeight test function

\end{fulllineitems}



\section{pygpc.TestBench module}
\label{\detokenize{pygpc:module-pygpc.TestBench}}\label{\detokenize{pygpc:pygpc-testbench-module}}\index{pygpc.TestBench (module)}\index{TestBench (class in pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBench}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{TestBench}}}{\emph{algorithm}, \emph{problem}, \emph{options}, \emph{n\_cpu}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

TestBench for gPC algorithms
\index{run() (pygpc.TestBench.TestBench method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBench.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
Run algorithms with test problems and save results

\end{fulllineitems}


\end{fulllineitems}

\index{TestBenchContinuous (class in pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBenchContinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{TestBenchContinuous}}}{\emph{algorithm}, \emph{options}, \emph{n\_cpu=1}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.TestBench.TestBench}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.TestBench.TestBench}}}}}

\end{fulllineitems}

\index{TestBenchContinuousND (class in pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBenchContinuousND}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{TestBenchContinuousND}}}{\emph{algorithm}, \emph{options}, \emph{dims}, \emph{n\_cpu=1}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.TestBench.TestBench}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.TestBench.TestBench}}}}}

\end{fulllineitems}

\index{TestBenchDiscontinuous (class in pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBenchDiscontinuous}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{TestBenchDiscontinuous}}}{\emph{algorithm}, \emph{options}, \emph{n\_cpu=1}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.TestBench.TestBench}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.TestBench.TestBench}}}}}

\end{fulllineitems}

\index{TestBenchDiscontinuousND (class in pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.TestBenchDiscontinuousND}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{TestBenchDiscontinuousND}}}{\emph{algorithm}, \emph{options}, \emph{dims}, \emph{n\_cpu=1}}{}
Bases: {\hyperref[\detokenize{pygpc:pygpc.TestBench.TestBench}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pygpc.TestBench.TestBench}}}}}

\end{fulllineitems}

\index{run\_test() (in module pygpc.TestBench)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.TestBench.run_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.TestBench.}}\sphinxbfcode{\sphinxupquote{run\_test}}}{\emph{algorithm}}{}
\end{fulllineitems}



\section{pygpc.Visualization module}
\label{\detokenize{pygpc:module-pygpc.Visualization}}\label{\detokenize{pygpc:pygpc-visualization-module}}\index{pygpc.Visualization (module)}
Functions and classes that provide visualisation functionalities
\index{Visualization (class in pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{Visualization}}}{\emph{dims=(10}, \emph{10)}}{}
Creates a new visualization in a new window. Any added sub-charts will be added to this window.

Visualisation(dims=(10, 10))
\index{figure\_number (pygpc.Visualization.Visualization.Visualisation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.Visualisation.figure_number}}\pysigline{\sphinxcode{\sphinxupquote{Visualisation.}}\sphinxbfcode{\sphinxupquote{figure\_number}}}
Number of figures that have been created
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, begin=0

\end{description}\end{quote}

\end{fulllineitems}

\index{horizontal\_padding (pygpc.Visualization.Visualization.Visualisation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.Visualisation.horizontal_padding}}\pysigline{\sphinxcode{\sphinxupquote{Visualisation.}}\sphinxbfcode{\sphinxupquote{horizontal\_padding}}}
Horizontal padding of plot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float, default=0.4

\end{description}\end{quote}

\end{fulllineitems}

\index{font\_size\_label (pygpc.Visualization.Visualization.Visualisation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.Visualisation.font_size_label}}\pysigline{\sphinxcode{\sphinxupquote{Visualisation.}}\sphinxbfcode{\sphinxupquote{font\_size\_label}}}
Font size of title
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, default=12

\end{description}\end{quote}

\end{fulllineitems}

\index{font\_size\_label (pygpc.Visualization.Visualization.Visualisation attribute)}

\begin{fulllineitems}
\pysigline{\sphinxcode{\sphinxupquote{Visualisation.}}\sphinxbfcode{\sphinxupquote{font\_size\_label}}}
Font size of label
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, default=12

\end{description}\end{quote}

\end{fulllineitems}

\index{graph\_lind\_width (pygpc.Visualization.Visualization.Visualisation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.Visualisation.graph_lind_width}}\pysigline{\sphinxcode{\sphinxupquote{Visualisation.}}\sphinxbfcode{\sphinxupquote{graph\_lind\_width}}}
Line width of graph
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, default 2

\end{description}\end{quote}

\end{fulllineitems}

\index{fig (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.fig}}\pysigline{\sphinxbfcode{\sphinxupquote{fig}}}
Handle of figure created by matplotlib.pyplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
mpl.figure

\end{description}\end{quote}

\end{fulllineitems}

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{dims}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{10}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{10}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Size of the newly created window

\end{description}\end{quote}
\index{add\_heat\_map() (pygpc.Visualization.Visualization method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.add_heat_map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_heat\_map}}}{\emph{title}, \emph{labels}, \emph{grid\_points}, \emph{data\_points}, \emph{v\_lim=(None}, \emph{None)}, \emph{x\_lim=None}, \emph{y\_lim=None}, \emph{colormap=None}}{}
Draw a 2D heatmap into the current figure.

add\_heat\_map(title, labels, grid\_points, data\_points, v\_lim=(None, None), x\_lim=None, y\_lim=None, colormap=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Title of the graph

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{labels}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str:str\} dict}}) \textendash{} \{‘x’: name of x-axis, ‘y’: name of y-axis\}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{grid\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Arrays of the x and y positions of the grid points e.g.: {[}np.array(x\_points), np.array(y\_points){]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray of the data points that are placed into the grid}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} x-limits for the function argument or value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} y-limits for the function argument or value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{v\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Limits of the color scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{colormap}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} The colormap to use

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_line\_plot() (pygpc.Visualization.Visualization method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.add_line_plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_line\_plot}}}{\emph{title}, \emph{labels}, \emph{data}, \emph{x\_lim=None}, \emph{y\_lim=None}}{}
Draw a 1D line graph into the current figure.

add\_line\_plot(title, labels, data, x\_lim=None, y\_lim=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Title of the graph

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{labels}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str:str\} dict}}) \textendash{} \{‘x’: name of x-axis, ‘y’: name of y-axis\}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} x-limits for the function argument or value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} y-limits for the function argument or value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Data that should be plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_scatter\_plot() (pygpc.Visualization.Visualization static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.add_scatter_plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{add\_scatter\_plot}}}{\emph{shape}, \emph{plot\_size}, \emph{color\_sequence}, \emph{colormap=None}, \emph{v\_lim=(None}, \emph{None)}}{}
Draw a scatter plot onto the current chart.

add\_scatter\_plot(shape, plot\_size, color\_sequence, colormap=None, v\_lim=(None, None))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str: np.ndarray\} dict}}) \textendash{} \{‘x’: positions on x-axis, ‘y’: positions on y-axis\}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} The marker size in the squared number of points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{color\_sequence}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Marker colors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{colormap}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} The colormap to use

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{v\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Limits of the color scale

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_new\_chart() (pygpc.Visualization.Visualization method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.create_new_chart}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_new\_chart}}}{\emph{layout\_id=None}}{}
Add a new subplot to the current visualization, so that multiple graphs can be overlaid onto one chart
(e.g. scatterplot over heatmap).

create\_new\_chart(layout\_id=None)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{layout\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{3-digit}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Denoting the position of the graph in figure (xyn : ‘x’=width, ‘y’=height of grid, ‘n’=position within grid)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_sub\_plot() (pygpc.Visualization.Visualization static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.create_sub_plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{create\_sub\_plot}}}{\emph{title}, \emph{labels}, \emph{x\_lim}, \emph{y\_lim}}{}
Set the title, labels and the axis limits of a plot.

create\_sub\_plot(title, labels, x\_lim, y\_lim)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Title of the plot

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{labels}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str:str\} dict}}) \textendash{} \{‘x’: name of x-axis, ‘y’: name of y-axis\}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} x-limits for the function argument or value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_lim}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} y-limits for the function argument or value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_number (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.figure_number}}\pysigline{\sphinxbfcode{\sphinxupquote{figure\_number}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{font\_size\_label (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.font_size_label}}\pysigline{\sphinxbfcode{\sphinxupquote{font\_size\_label}}\sphinxbfcode{\sphinxupquote{ = 12}}}
\end{fulllineitems}

\index{font\_size\_title (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.font_size_title}}\pysigline{\sphinxbfcode{\sphinxupquote{font\_size\_title}}\sphinxbfcode{\sphinxupquote{ = 12}}}
\end{fulllineitems}

\index{graph\_line\_width (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.graph_line_width}}\pysigline{\sphinxbfcode{\sphinxupquote{graph\_line\_width}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{horizontal\_padding (pygpc.Visualization.Visualization attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.horizontal_padding}}\pysigline{\sphinxbfcode{\sphinxupquote{horizontal\_padding}}\sphinxbfcode{\sphinxupquote{ = 0.4}}}
\end{fulllineitems}

\index{show() (pygpc.Visualization.Visualization static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.Visualization.show}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{show}}}{}{}
Show plots.

\end{fulllineitems}


\end{fulllineitems}

\index{b2rcw() (in module pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.b2rcw}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{b2rcw}}}{\emph{cmin\_input}, \emph{cmax\_input}}{}
Blue, white, and red color map.
This function is designed to generate a blue to red colormap. The color of the colorbar is from blue to white and
then to red, corresponding to the data values from negative to zero to positive, respectively.
The color white always corresponds to value zero. The brightness of blue and red will change according to your
setting, so that the brightness of the color corresponded to the color of his opposite number.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmin\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum value of data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmax\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Maximum value of data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{newmap} \textendash{} Colormap

\item[{Return type}] \leavevmode
ndarray of float {[}N\_RGB x 3{]}

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b2rcw\PYGZus{}cmap\PYGZus{}1} \PYG{o}{=} \PYG{n}{make\PYGZus{}cmap}\PYG{p}{(}\PYG{n}{b2rcw}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} is from light blue to deep red}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b2rcw\PYGZus{}cmap\PYGZus{}2} \PYG{o}{=} \PYG{n}{make\PYGZus{}cmap}\PYG{p}{(}\PYG{n}{b2rcw}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} is from deep blue to deep red}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{make\_cmap() (in module pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.make_cmap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{make\_cmap}}}{\emph{colors}, \emph{position=None}, \emph{bit=False}}{}
make\_cmap takes a list of tuples which contain RGB values. The RGB
values may either be in 8-bit {[}0 to 255{]} (in which bit must be set to
True when called) or arithmetic {[}0 to 1{]} (default). make\_cmap returns
a cmap with equally spaced colors.
Arrange your tuples so that the first color is the lowest value for the
colorbar and the last is the highest.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{colors}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of 3-tuples}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_rgb}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} RGB values. The RGB values may either be in 8-bit {[}0 to 255{]} (in which bit must be set to True when called)
or arithmetic {[}0 to 1{]} (default).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_rgb}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Contains values from 0 to 1 to dictate the location of each color.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=False}}) \textendash{} Defines if colors are in 8-bit {[}0 to 255{]} (True) or arithmetic {[}0 to 1{]} (False)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{cmap} \textendash{} Colormap

\item[{Return type}] \leavevmode
mpl.colors instance

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_2d\_grid() (in module pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.plot_2d_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{plot\_2d\_grid}}}{\emph{coords}, \emph{weights=None}, \emph{fn\_plot=None}}{}
Plot 2D grid and save it as fn\_plot.pdf
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Grid points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_grid}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Integration weights

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of plot so save (.pdf)

\end{itemize}

\item[{Returns}] \leavevmode
Plot of grid-points

\item[{Return type}] \leavevmode
\textless{}file\textgreater{} .pdf file

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_beta\_pdf\_fit() (in module pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.plot_beta_pdf_fit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{plot\_beta\_pdf\_fit}}}{\emph{data}, \emph{a\_beta}, \emph{b\_beta}, \emph{p\_beta}, \emph{q\_beta}, \emph{a\_uni=None}, \emph{b\_uni=None}, \emph{interactive=True}, \emph{fn\_plot=None}, \emph{xlabel='\$x\$'}, \emph{ylabel='\$p(x)\$'}}{}
Plot data, fitted beta pdf (and corresponding uniform) distribution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Data to fit beta distribution on

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a\_beta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lower limit of beta distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b\_beta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Upper limit of beta distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p\_beta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} First shape parameter of beta distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q\_beta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Second shape parameter of beta distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a\_uni}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Lower limit of uniform distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b\_uni}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Upper limit of uniform distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interactive}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default = True}}) \textendash{} Show plot (True/False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_plot}} \textendash{} Filename of plot so save (as .png and .pdf)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xlabel}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Label of x-axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ylabel}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Label of y-axis

\end{itemize}

\item[{Returns}] \leavevmode
Plots

\item[{Return type}] \leavevmode
\textless{}file\textgreater{} .png and .pdf files

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_sobol\_indices() (in module pygpc.Visualization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Visualization.plot_sobol_indices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Visualization.}}\sphinxbfcode{\sphinxupquote{plot\_sobol\_indices}}}{\emph{sobol\_rel\_order\_mean}, \emph{sobol\_rel\_1st\_order\_mean}, \emph{fn\_plot}, \emph{random\_vars}}{}
Plot the Sobol indices into different sub-plots.

plot\_sobol\_indices(sobol\_rel\_order\_mean, sobol\_rel\_1st\_order\_mean, fn\_plot, random\_vars)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_rel\_order\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_sobol}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,)
over all output quantities

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_rel\_1st\_order\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Average proportion of the random variables of the 1st order Sobol indices to the total variance over all
output quantities

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of plot

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{random\_vars}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} String labels of the random variables

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pygpc.Worker module}
\label{\detokenize{pygpc:module-pygpc.Worker}}\label{\detokenize{pygpc:pygpc-worker-module}}\index{pygpc.Worker (module)}\index{init() (in module pygpc.Worker)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Worker.init}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Worker.}}\sphinxbfcode{\sphinxupquote{init}}}{\emph{queue}}{}
This is a wrapper script to be called by the ‘multiprocessing.map’ function
to calculate the model functions in parallel.

This function will be called upon initialization of the process.
It sets a global variable denoting the ID of this process that can
be read by any function of this process
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{queue}} (\sphinxstyleliteralemphasis{\sphinxupquote{multiprocessing.Queue}}) \textendash{} the queue object that manages the unique IDs of the process pool

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (in module pygpc.Worker)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.Worker.run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.Worker.}}\sphinxbfcode{\sphinxupquote{run}}}{\emph{obj}}{}
This is the main worker function of the process.
Methods of the provided object will be called here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obj}} (\sphinxstyleliteralemphasis{\sphinxupquote{any callable object}}) \textendash{} \begin{description}
\item[{The object that}] \leavevmode\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\item {} 
handles the simulation work

\item {} 
reading previous results

\item {} 
writing the calculated result fields

\item {} 
printing global process

\end{enumerate}

\end{description}


\end{description}\end{quote}

\end{fulllineitems}



\section{pygpc.io module}
\label{\detokenize{pygpc:module-pygpc.io}}\label{\detokenize{pygpc:pygpc-io-module}}\index{pygpc.io (module)}
Functions that provide input and output functionality
\index{iprint() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.iprint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{iprint}}}{\emph{message}, \emph{verbose=True}, \emph{tab=None}}{}
Function that prints out a message over the python logging module

iprint(message, verbose=True)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} String to print in standard output

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=True}}) \textendash{} Determines if string is printed out

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tab}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of tabs before message

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_data\_hdf5() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.read_data_hdf5}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{read\_data\_hdf5}}}{\emph{fname}, \emph{loc}}{}
Read data from .hdf5 file (e.g. coeffs, mean, std, …).

load\_data\_hdf5(fname, loc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to input file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} location (folder and name) in hdf5 file (e.g. data/phi)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{data} \textendash{} Loaded data from .hdf5 file

\item[{Return type}] \leavevmode
ndarray of float

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_gpc\_pkl() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.read_gpc_pkl}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{read\_gpc\_pkl}}}{\emph{fname}}{}
Read gPC object including information about input pdfs, polynomials, grid etc.

object = read\_gpc\_obj(fname)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to input file

\item[{Returns}] \leavevmode
\sphinxstylestrong{obj} \textendash{} GPC object containing instances of Basis, Problem and Model.

\item[{Return type}] \leavevmode
GPC Object

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_sobol\_idx\_txt() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.read_sobol_idx_txt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{read\_sobol\_idx\_txt}}}{\emph{fname}}{}
Read sobol\_idx list from file.

read\_sobol\_idx\_txt(fname)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to input file

\item[{Returns}] \leavevmode
\sphinxstylestrong{sobol\_idx} \textendash{} List of parameter label indices belonging to Sobol indices

\item[{Return type}] \leavevmode
{[}N\_sobol{]} list of np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{wprint() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.wprint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{wprint}}}{\emph{message}, \emph{verbose=True}, \emph{tab=None}}{}
Function that prints out a warning message over the python logging module

wprint(message, verbose=True)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} String to print in standard output

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=True}}) \textendash{} Determines if string is printed out

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tab}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of tabs before message

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_data\_hdf5() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.write_data_hdf5}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{write\_data\_hdf5}}}{\emph{data}, \emph{fname}, \emph{loc}}{}
Write quantity of interest in .hdf5 file (e.g. coeffs, mean, std, …).

write\_data\_hdf5(data, fname, loc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} data to save

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} location (folder and name) in hdf5 file (e.g. data/phi)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_data\_txt() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.write_data_txt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{write\_data\_txt}}}{\emph{data}, \emph{fname}}{}
Write data (quantity of interest) in .txt file (e.g. coeffs, mean, std, …).

write\_data\_txt(data, fname)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Data to save

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to output file

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}file\textgreater{}} \textendash{} File containing the data (tab delimited)

\item[{Return type}] \leavevmode
txt file

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_gpc\_pkl() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.write_gpc_pkl}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{write\_gpc\_pkl}}}{\emph{obj}, \emph{fname}}{}
Write gPC object including information about the Basis, Problem and Model as pickle file.

write\_gpc\_obj(obj, fname)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obj}} ({\hyperref[\detokenize{pygpc:pygpc.GPC.GPC}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{GPC}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{derived class}}) \textendash{} Class instance containing the gPC information

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output file

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}file\textgreater{}} \textendash{} File containing the GPC object

\item[{Return type}] \leavevmode
pkl file

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_log\_sobol() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.write_log_sobol}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{write\_log\_sobol}}}{\emph{fname}, \emph{random\_vars}, \emph{sobol\_rel\_order\_mean}, \emph{sobol\_rel\_1st\_order\_mean}, \emph{sobol\_extracted\_idx\_1st}}{}
Write average ratios of Sobol indices into logfile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path of logfile

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{random\_vars}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Labels of random variables

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_rel\_order\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,).
(over all output quantities)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_rel\_1st\_order\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Average proportion of the random variables of the 1st order Sobol indices to the total variance.
(over all output quantities)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_extracted\_idx\_1st}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_sobol\_1st}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Indices of extracted 1st order Sobol indices corresponding to SGPC.random\_vars.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}File\textgreater{}} \textendash{} Logfile containing information about the average ratios of 1st order Sobol indices w.r.t. the total variance

\item[{Return type}] \leavevmode
txt file

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_sobol\_idx\_txt() (in module pygpc.io)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.io.write_sobol_idx_txt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.io.}}\sphinxbfcode{\sphinxupquote{write\_sobol\_idx\_txt}}}{\emph{sobol\_idx}, \emph{fname}}{}
Write sobol\_idx list in file.

write\_sobol\_idx\_txt(sobol\_idx, filename)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sobol\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{N\_sobol}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{list of np.ndarray}}) \textendash{} List of parameter label indices belonging to Sobol indices

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to output file

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}file\textgreater{}} \textendash{} File containing the sobol index list.

\item[{Return type}] \leavevmode
txt file

\end{description}\end{quote}

\end{fulllineitems}



\section{pygpc.misc module}
\label{\detokenize{pygpc:module-pygpc.misc}}\label{\detokenize{pygpc:pygpc-misc-module}}\index{pygpc.misc (module)}
Functions and classes that provide data and methods with general usage in the pygpc package
\index{display\_fancy\_bar() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.display_fancy_bar}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{display\_fancy\_bar}}}{\emph{text}, \emph{i}, \emph{n\_i}, \emph{more\_text=None}}{}
Display a simple progress bar. Call in each iteration and start with i=1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Text to display in front of actual iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Actual iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Total number of iterations

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{more\_text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}) \textendash{} Text that is displayed on an extra line above the bar.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

fancy\_bar(‘Run’,7,10):
Run 07 from 10 {[}================================        {]} 70\%

fancy\_bar(Run,9,10,’Some more text’):
Some more text
Run 09 from 10 {[}======================================= {]} 90\%

\end{fulllineitems}

\index{get\_all\_combinations() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_all_combinations}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_all\_combinations}}}{\emph{array}, \emph{number\_elements}}{}
Compute all k-tuples (e\_1, e\_2, …, e\_k) of combinations of the set of elements of the input array where
e\_n+1 \textgreater{} e\_n.
combinations = get\_all\_combinations(array, number\_elements)
:param array: Array to perform the combinatorial problem with
:type array: np.ndarray
:param number\_elements: Number of elements in tuple
:type number\_elements: int
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{combinations} \textendash{} Array of combination vectors

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_array\_unique\_rows() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_array_unique_rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_array\_unique\_rows}}}{\emph{array}}{}
Compute unique rows of 2D array and delete rows that are redundant.

unique = get\_array\_unique\_rows(array)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Matrix with k redundant rows

\item[{Returns}] \leavevmode
\sphinxstylestrong{unique} \textendash{} Matrix without k redundant rows

\item[{Return type}] \leavevmode
ndarray of float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_beta\_pdf\_fit() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_beta_pdf_fit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_beta\_pdf\_fit}}}{\emph{data}, \emph{beta\_tolerance=0}, \emph{uni\_interval=0}, \emph{fn\_plot=None}}{}
Fit data to a beta distribution in the interval {[}a, b{]}.

beta\_parameters, moments, p\_value, uni\_parameters = get\_beta\_pdf\_fit(data, beta\_tolerance=0, uni\_interval=0)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Data to fit beta distribution on

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta\_tolerance}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=0}}) \textendash{} Tolerance interval to calculate the bounds of beta distribution
from observed data, e.g. 0.2 (+-20\% tolerance on observed max and min value)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uni\_interval}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=0}}) \textendash{} uniform distribution interval defined as fraction of beta distribution interval (e.g. 0.95 (95\%))

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of plot so save (.pdf and .png)

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{beta\_parameters} (\sphinxstyleemphasis{list of float {[}4{]}}) \textendash{} Two shape parameters and lower and upper limit {[}p, q, a, b{]}

\item {} 
\sphinxstylestrong{moments} (\sphinxstyleemphasis{list of float {[}4{]}}) \textendash{} Mean and std of raw data and fitted beta distribution {[}data\_mean, data\_std, beta\_mean, beta\_std{]}

\item {} 
\sphinxstylestrong{p\_value} (\sphinxstyleemphasis{float}) \textendash{} p-value of the Kolmogorov Smirnov test

\item {} 
\sphinxstylestrong{uni\_parameters} (\sphinxstyleemphasis{list of float {[}2{]}}) \textendash{} Lower and upper limits of uniform distribution {[}a, b{]}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_cartesian\_product() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_cartesian_product}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_cartesian\_product}}}{\emph{array\_list}}{}
Generate a cartesian product of input arrays (all combinations).

cartesian\_product = get\_cartesian\_product(array\_list)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{array\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of 1D ndarray of float}}) \textendash{} Arrays to compute the cartesian product with

\item[{Returns}] \leavevmode
\sphinxstylestrong{cartesian\_product} \textendash{} Array containing the cartesian products (all combinations of input vectors)
(M, len(arrays))

\item[{Return type}] \leavevmode
ndarray of float

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pygpc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out} \PYG{o}{=} \PYG{n}{pygpc}\PYG{o}{.}\PYG{n}{get\PYGZus{}cartesian\PYGZus{}product}\PYG{p}{(}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_list\_multi\_delete() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_list_multi_delete}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_list\_multi\_delete}}}{\emph{input\_list}, \emph{index}}{}
Delete multiple entries from list.

input\_list = get\_list\_multi\_delete(input\_list, index)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Simple list

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of integer}}) \textendash{} List of indices to delete

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{input\_list} \textendash{} Input list without entries specified in index

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_indices\_max\_order() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_multi_indices_max_order}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_multi\_indices\_max\_order}}}{\emph{dim}, \emph{order\_max}, \emph{order\_max\_norm=1.0}}{}
Computes all multi-indices with a maximum overall order of max\_order.

multi\_indices = get\_multi\_indices\_max\_order(length, max\_order)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random parameters (length of multi-index tuples)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Maximum global expansion order.
The maximum expansion order considers the sum of the orders of combined polynomials together with the
chosen norm “order\_max\_norm”. Typically this norm is 1 such that the maximum order is the sum of all
monomial orders.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_max\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Norm for which the maximum global expansion order is defined {[}0, 1{]}. Values \textless{} 1 decrease the total number
of polynomials in the expansion such that interaction terms are penalized more.
sum(a\_i\textasciicircum{}q)\textasciicircum{}1/q \textless{}= p, where p is order\_max and q is order\_max\_norm (for more details see eq (11) in {[}1{]}).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{multi\_indices} \textendash{} Multi-indices for a maximum order gPC assuming a certain order norm.

\item[{Return type}] \leavevmode
np.ndarray {[}n\_basis x dim{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_normalized\_rms\_deviation() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_normalized_rms_deviation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_normalized\_rms\_deviation}}}{\emph{array}, \emph{array\_ref}, \emph{x\_axis=False}}{}
Determine the normalized root mean square deviation between input data and reference data in {[}\%{]}.

normalized\_rms = get\_normalized\_rms(array, array\_ref)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} input data {[} (x), y0, y1, y2 … {]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{array\_ref}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} reference data {[} (x\_ref), y0\_ref, y1\_ref, y2\_ref … {]}
if array\_ref is 1D, all sizes have to match

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=False}}) \textendash{} If True, the first column of array and array\_ref is interpreted as the x-axis, where the data points are
evaluated. If False, the data points are assumed to be at the same location.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{normalized\_rms} \textendash{} Normalized root mean square deviation between the columns of array and array\_ref

\item[{Return type}] \leavevmode
ndarray of float {[}array.shape{[}1{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_coeffs() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_num_coeffs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_num\_coeffs}}}{\emph{order}, \emph{dim}}{}
Calculate the number of gPC coefficients by the maximum order and the number of random variables.

num\_coeffs = (order+dim)! / (order! * dim!)

num\_coeffs = get\_num\_coeffs(order , dim)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Maximum order of expansion

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random variables

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{num\_coeffs} \textendash{} Number of gPC coefficients and polynomials

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_coeffs\_sparse() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_num_coeffs_sparse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_num\_coeffs\_sparse}}}{\emph{order\_dim\_max}, \emph{order\_glob\_max}, \emph{order\_inter\_max}, \emph{dim}, \emph{order\_glob\_max\_norm=1}}{}
Calculate the number of gPC coefficients for a specific maximum order in each dimension “order\_dim\_max”,
global maximum order “order\_glob\_max” and the interaction order “order\_inter\_max”.

num\_coeffs\_sparse = get\_num\_coeffs\_sparse(order\_dim\_max, order\_glob\_max, order\_inter\_max, dim)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_dim\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Maximum order in each dimension

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_glob\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Maximum global order of interacting polynomials

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_inter\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Interaction order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of random variables

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order\_glob\_max\_norm}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Norm, which defines how the orders are accumulated to derive the total order (default: 1-norm).
Values smaller than one restrict higher orders and shrink the basis.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{num\_coeffs\_sparse} \textendash{} Number of gPC coefficients and polynomials

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pdf\_beta() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_pdf_beta}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_pdf\_beta}}}{\emph{x}, \emph{p}, \emph{q}, \emph{a}, \emph{b}}{}
Calculate the probability density function of the beta distribution in the interval {[}a, b{]}.
\begin{description}
\item[{pdf = (gamma(p)*gamma(q)/gamma(p+q).*(b-a)**(p+q-1))**(-1) *}] \leavevmode
(x-a)**(p-1) * (b-x)**(q-1);

\end{description}

pdf = get\_pdf\_beta(x, p, q, a, b)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Values of random variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} lower boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} upper boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} First shape parameter defining the distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Second shape parameter defining the distribution

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pdf} \textendash{} Probability density

\item[{Return type}] \leavevmode
ndarray of float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_rotation\_matrix() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.get_rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{get\_rotation\_matrix}}}{\emph{theta}}{}
Generate rotation matrix from euler angles.

rotation\_matrix = get\_rotation\_matrix(theta)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Euler angles

\item[{Returns}] \leavevmode
\sphinxstylestrong{rotation\_matrix} \textendash{} Rotation matrix computed from euler angles

\item[{Return type}] \leavevmode
ndarray of float {[}3, 3{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{list2dict() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.list2dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{list2dict}}}{\emph{l}}{}
Transform list of dicts with same keys to dict of list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of dict}}) \textendash{} List containing dictionaries with same keys

\item[{Returns}] \leavevmode
\sphinxstylestrong{d} \textendash{} Dictionary containing the entries in a list

\item[{Return type}] \leavevmode
dict of lists

\end{description}\end{quote}

\end{fulllineitems}

\index{mutual\_coherence() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.mutual_coherence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{mutual\_coherence}}}{\emph{array}}{}
Calculate the mutual coherence of a matrix A. It can also be referred as the cosine of the smallest angle
between two columns.

mutual\_coherence = mutual\_coherence(array)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}) \textendash{} Input matrix

\item[{Returns}] \leavevmode
\sphinxstylestrong{mutual\_coherence} \textendash{} Mutual coherence

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_sphere() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.sample_sphere}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{sample\_sphere}}}{\emph{n\_points}, \emph{r}}{}
Creates n\_points evenly spread in a sphere of radius r.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of points to be spread, must be odd

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Radius of sphere

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{points} \textendash{} Evenly spread points in a unit sphere

\item[{Return type}] \leavevmode
ndarray of float {[}N x 3{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{wrap\_function() (in module pygpc.misc)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.misc.wrap_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.misc.}}\sphinxbfcode{\sphinxupquote{wrap\_function}}}{\emph{fn}, \emph{x}, \emph{args}}{}
Function wrapper to call anonymous function with variable number of arguments (tuple).

wrap\_function(fn, x, args)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} anonymous function to call

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} parameters of function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} arguments of function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{function\_wrapper} \textendash{} wrapped function

\item[{Return type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}



\section{pygpc.postprocessing module}
\label{\detokenize{pygpc:module-pygpc.postprocessing}}\label{\detokenize{pygpc:pygpc-postprocessing-module}}\index{pygpc.postprocessing (module)}\index{get\_sensitivities\_hdf5() (in module pygpc.postprocessing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.postprocessing.get_sensitivities_hdf5}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.postprocessing.}}\sphinxbfcode{\sphinxupquote{get\_sensitivities\_hdf5}}}{\emph{fn\_gpc}, \emph{output\_idx=False}, \emph{calc\_sobol=True}, \emph{calc\_global\_sens=False}, \emph{calc\_pdf=False}}{}
Post-processes the gPC expansion and adds mean, standard deviation, relative standard deviation, variance, Sobol
indices, global derivative based sensitivity coefficients and probability density functions of output quantities to
.hdf5 file of gPC.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_gpc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of gPC .pkl object and corresponding .hdf5 results file (without file extension)
(e.g. …/foo/gpc)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{nparray of int}}) \textendash{} Indices of output quantities (QOIs) to consider in postprocessing (default: all)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calc\_sobol}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Calculate Sobol indices (default: True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calc\_global\_sens}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Calculate global derivative based sensitivities (default: False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calc\_pdf}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Calculate probability density functions of output quantities (default: False)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{\textless{}File\textgreater{}} \textendash{} Adds datasets “sens/…” to the gPC .hdf5 file

\item[{Return type}] \leavevmode
hdf5

\end{description}\end{quote}
\subsubsection*{Example}

The content of .hdf5 files can be shown using the tool HDFView
(\sphinxurl{https://support.hdfgroup.org/products/java/hdfview/})
\begin{description}
\item[{::}] \leavevmode
sens
I—/mean               {[}n\_qoi{]}                 Mean of QOIs
I—/std                {[}n\_qoi{]}                 Standard deviation of QOIs
I—/rstd               {[}n\_qoi{]}                 Relative standard deviation of QOIs
I—/var                {[}n\_qoi{]}                 Variance of QOIs
I—/sobol              {[}n\_sobol x n\_qoi{]}       Sobol indices (all available orders)
I—/sobol\_idx\_bool     {[}n\_sobol x n\_dim{]}       Corresponding parameter (combinations) of Sobol indices
I—/global\_sens        {[}n\_dim x n\_qoi{]}         Global derivative based sensitivity coefficients
I—/pdf\_x              {[}100 x n\_qoi{]}           x-axis values of output PDFs
I—/pdf\_y              {[}100 x n\_qoi{]}           y-axis values of output PDFs

\end{description}

\end{fulllineitems}



\section{pygpc.validation module}
\label{\detokenize{pygpc:module-pygpc.validation}}\label{\detokenize{pygpc:pygpc-validation-module}}\index{pygpc.validation (module)}\index{validate\_gpc\_mc() (in module pygpc.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.validation.validate_gpc_mc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.validation.}}\sphinxbfcode{\sphinxupquote{validate\_gpc\_mc}}}{\emph{gpc}, \emph{coeffs}, \emph{n\_samples=10000.0}, \emph{output\_idx=0}, \emph{n\_cpu=1}, \emph{fn\_out=None}}{}
Compares gPC approximation with original model function. Evaluates both at “n\_samples” sampling points and
evaluates the root mean square deviation. It also computes the pdf at the output quantity with output\_idx
and saves the plot as fn\_pdf.png and fn\_pdf.pdf.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpc}} (\sphinxstyleliteralemphasis{\sphinxupquote{GPC object instance}}) \textendash{} GPC object containing all information i.e., Problem, Model, Grid, Basis, RandomParameter instances

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_coeffs x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples to validate the gPC approximation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=None}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{1 x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index of output quantities to consider (if output\_idx=None, all output quantities are considered)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ncpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=1}}) \textendash{} Number of CPU cores to use (parallel function evaluations) to evaluate original model function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of validation results and pdf plot comparing original vs gPC model

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{nrmsd} (\sphinxstyleemphasis{ndarray of float {[}n\_out{]}}) \textendash{} Normalized root mean square deviation for all output quantities between gPC and original model

\item {} 
\sphinxstylestrong{\textless{}file\textgreater{}} (\sphinxstyleemphasis{.hdf5 file}) \textendash{} Data file containing the sampling points, the results and the pdfs of the original and the gpc approximation

\item {} 
\sphinxstylestrong{\textless{}file\textgreater{}} (\sphinxstyleemphasis{.pdf file}) \textendash{} Plot showing the pdfs of the original and the gpc approximation

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{validate\_gpc\_plot() (in module pygpc.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygpc:pygpc.validation.validate_gpc_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygpc.validation.}}\sphinxbfcode{\sphinxupquote{validate\_gpc\_plot}}}{\emph{gpc}, \emph{coeffs}, \emph{random\_vars}, \emph{n\_grid=None}, \emph{coords=None}, \emph{output\_idx=0}, \emph{data\_original=None}, \emph{fn\_out=None}, \emph{n\_cpu=1}}{}
Compares gPC approximation with original model function. Evaluates both at n\_grid (x n\_grid) sampling points and
calculate the difference between two solutions at the output quantity with output\_idx and saves the plot as
{\color{red}\bfseries{}*}\_QOI\_idx\_\textless{}output\_idx\textgreater{}.png/pdf. Also generates one .hdf5 results file with the evaluation results.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpc}} (\sphinxstyleliteralemphasis{\sphinxupquote{GPC object instance}}) \textendash{} GPC object containing all information i.e., Problem, Model, Grid, Basis, RandomParameter instances

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeffs}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_coeffs x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} GPC coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{random\_vars}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Names of the random variables, the analysis is performed for one or max. two random variables

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of samples in each dimension to compare the gPC approximation with the original model function.
A cartesian grid is generated based on the limits of the specified random\_vars

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_coords x n\_dim}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Parameter combinations for the random\_vars the comparison is conducted with

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=0}}) \textendash{} Indices of output quantity to consider

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_original}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray of float}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_coords x n\_out}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default: None}}) \textendash{} If available, data of original model function at grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename of plot comparing original vs gPC model ({\color{red}\bfseries{}*}\_QOI\_idx\_\textless{}output\_idx\textgreater{}.png is added)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_cpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default=1}}) \textendash{} Number of CPU cores to use to calculate results of original model on grid.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{\textless{}file\textgreater{}} (\sphinxstyleemphasis{.hdf5 file}) \textendash{} Data file containing the grid points and the results of the original and the gpc approximation

\item {} 
\sphinxstylestrong{\textless{}file\textgreater{}} (\sphinxstyleemphasis{.png and .pdf file}) \textendash{} Plot comparing original vs gPC model

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{pygpc:module-pygpc}}\label{\detokenize{pygpc:module-contents}}\index{pygpc (module)}
A package that provides submodules to perform polynomial chaos uncertainty analysis on complex dynamic systems.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{pygpc}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc}}
\item\relax\sphinxstyleindexentry{pygpc.AbstractModel}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.AbstractModel}}
\item\relax\sphinxstyleindexentry{pygpc.Algorithm}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Algorithm}}
\item\relax\sphinxstyleindexentry{pygpc.Basis}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Basis}}
\item\relax\sphinxstyleindexentry{pygpc.BasisFunction}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.BasisFunction}}
\item\relax\sphinxstyleindexentry{pygpc.Computation}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Computation}}
\item\relax\sphinxstyleindexentry{pygpc.EGPC}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.EGPC}}
\item\relax\sphinxstyleindexentry{pygpc.GPC}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.GPC}}
\item\relax\sphinxstyleindexentry{pygpc.Grid}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Grid}}
\item\relax\sphinxstyleindexentry{pygpc.io}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.io}}
\item\relax\sphinxstyleindexentry{pygpc.misc}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.misc}}
\item\relax\sphinxstyleindexentry{pygpc.postprocessing}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.postprocessing}}
\item\relax\sphinxstyleindexentry{pygpc.Problem}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Problem}}
\item\relax\sphinxstyleindexentry{pygpc.RandomParameter}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.RandomParameter}}
\item\relax\sphinxstyleindexentry{pygpc.SGPC}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.SGPC}}
\item\relax\sphinxstyleindexentry{pygpc.Test}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Test}}
\item\relax\sphinxstyleindexentry{pygpc.TestBench}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.TestBench}}
\item\relax\sphinxstyleindexentry{pygpc.testfunctions}\sphinxstyleindexpageref{pygpc.testfunctions:\detokenize{module-pygpc.testfunctions}}
\item\relax\sphinxstyleindexentry{pygpc.testfunctions.testfunctions}\sphinxstyleindexpageref{pygpc.testfunctions:\detokenize{module-pygpc.testfunctions.testfunctions}}
\item\relax\sphinxstyleindexentry{pygpc.validation}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.validation}}
\item\relax\sphinxstyleindexentry{pygpc.Visualization}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Visualization}}
\item\relax\sphinxstyleindexentry{pygpc.Worker}\sphinxstyleindexpageref{pygpc:\detokenize{module-pygpc.Worker}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}