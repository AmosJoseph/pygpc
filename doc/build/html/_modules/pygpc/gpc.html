
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pygpc.gpc &#8212; pygpc 2018 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pygpc.gpc</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class that provides general polynomial chaos methods</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>

<span class="kn">from</span> <span class="nn">.misc</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.grid</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.postproc</span> <span class="k">import</span> <span class="o">*</span>


<span class="c1"># TODO: transform into abstract base class</span>
<div class="viewcode-block" id="gPC"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC">[docs]</a><span class="k">class</span> <span class="nc">gPC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General gPC base class</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    N_grid: int</span>
<span class="sd">        number of grid points</span>
<span class="sd">    N_poly: int</span>
<span class="sd">        number of polynomials psi</span>
<span class="sd">    N_samples: int</span>
<span class="sd">        number of samples xi</span>
<span class="sd">    N_out: int</span>
<span class="sd">        number of output coefficients</span>
<span class="sd">    dim: int</span>
<span class="sd">        number of uncertain parameters to process</span>
<span class="sd">    pdf_type: [dim] list of str</span>
<span class="sd">        type of pdf &#39;beta&#39; or &#39;norm&#39;</span>
<span class="sd">    pdf_shape: list of list of float</span>
<span class="sd">        shape parameters of pdfs</span>
<span class="sd">        beta-dist:   [[alpha], [beta]    ]</span>
<span class="sd">        normal-dist: [[mean],  [variance]]</span>
<span class="sd">    limits: list of list of float</span>
<span class="sd">        upper and lower bounds of random variables</span>
<span class="sd">        beta-dist:   [[a1 ...], [b1 ...]]</span>
<span class="sd">        normal-dist: [[0 ... ], [0 ... ]] (not used)</span>
<span class="sd">    order: [dim] list of int</span>
<span class="sd">        maximum individual expansion order</span>
<span class="sd">        generates individual polynomials also if maximum expansion order in order_max is exceeded</span>
<span class="sd">    order_max: int</span>
<span class="sd">        maximum expansion order (sum of all exponents)</span>
<span class="sd">        the maximum expansion order considers the sum of the orders of combined polynomials only</span>
<span class="sd">    interaction_order: int</span>
<span class="sd">        number of random variables, which can interact with each other</span>
<span class="sd">        all polynomials are ignored, which have an interaction order greater than the specified</span>
<span class="sd">    grid: grid object</span>
<span class="sd">        grid object generated in grid.py including grid.coords and grid.coords_norm</span>
<span class="sd">    random_vars: [dim] list of str</span>
<span class="sd">        string labels of the random variables</span>
<span class="sd">    sobol: [N_sobol x N_out] np.ndarray</span>
<span class="sd">        Sobol indices of N_out output quantities</span>
<span class="sd">    sobol_idx: [N_sobol] list of np.ndarray</span>
<span class="sd">        List of parameter label indices belonging to Sobol indices</span>
<span class="sd">    cpu: bool</span>
<span class="sd">        flag to execute the calculation on the cpu</span>
<span class="sd">    gpu: bool</span>
<span class="sd">        flag to execute the calculation on the gpu</span>
<span class="sd">    verbose: bool</span>
<span class="sd">        boolean value to determine if to print out the progress into the standard output</span>
<span class="sd">    gpc_matrix: [N_samples x N_poly] np.ndarray</span>
<span class="sd">        generalized polynomial chaos matrix</span>
<span class="sd">    gpc_matrix_inv: [N_poly x N_samples] np.ndarray</span>
<span class="sd">        pseudo inverse of the generalized polynomial chaos matrix</span>
<span class="sd">    gpc_coeffs: [N_poly x N_out] np.ndarray</span>
<span class="sd">        coefficient matrix of independent regions of interest for every coefficient</span>
<span class="sd">    poly: [dim x order_span] list of list of np.poly1d:</span>
<span class="sd">        polynomial objects containing the coefficients that are used to build the gpc matrix</span>
<span class="sd">    poly_gpu: np.ndarray</span>
<span class="sd">        polynomial coefficients stored in a np.ndarray that can be processed on a graphic card</span>
<span class="sd">    poly_idx: [N_poly x dim] np.ndarray</span>
<span class="sd">        multi indices to determine the degree of the used sub-polynomials</span>
<span class="sd">    poly_idx_gpu [N_poly x dim] np.ndarray</span>
<span class="sd">        multi indices to determine the degree of the used sub-polynomials stored in a np.ndarray that can be processed</span>
<span class="sd">        on a graphic card</span>
<span class="sd">    poly_der: [dim x order_span] list of list of np.poly1d:</span>
<span class="sd">        derivative of the polynomial objects containing the coefficients that are used to build the gpc matrix</span>
<span class="sd">    poly_norm: [order_span x dim] np.ndarray</span>
<span class="sd">        normalizing scaling factors of the used sub-polynomials</span>
<span class="sd">    poly_norm_basis: [N_poly] np.ndarray</span>
<span class="sd">        normalizing scaling factors of the polynomial basis functions</span>
<span class="sd">    sobol_idx_bool: list of np.ndarray of bool</span>
<span class="sd">        boolean mask that determines which multi indices are unique</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_coeffs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_gpu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx_gpu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm_basis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sobol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sobol_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sobol_idx_bool</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_random_vars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix_inv</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="gPC.init_polynomial_coeffs"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.init_polynomial_coeffs">[docs]</a>    <span class="k">def</span> <span class="nf">init_polynomial_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_begin</span><span class="p">,</span> <span class="n">order_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate polynomial basis functions of a given order range and add it to the polynomial lookup tables.</span>
<span class="sd">        The size, including the polynomials that won&#39;t be used, is [max_individual_order x dim].</span>

<span class="sd">        .. math::</span>
<span class="sd">           \\begin{tabular}{l*{4}{c}}</span>
<span class="sd">            Polynomial          &amp; Dimension 1 &amp; Dimension 2 &amp; ... &amp; Dimension M \\\\</span>
<span class="sd">           \\hline</span>
<span class="sd">            Polynomial 1        &amp; [Coefficients] &amp; [Coefficients] &amp; \\vdots &amp; [Coefficients] \\\\</span>
<span class="sd">            Polynomial 2        &amp; 0 &amp; [Coefficients] &amp; \\vdots &amp; [Coefficients] \\\\</span>
<span class="sd">           \\vdots              &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\</span>
<span class="sd">            Polynomial N        &amp; [Coefficients] &amp; [Coefficients] &amp; 0 &amp; [Coefficients] \\\\</span>
<span class="sd">           \\end{tabular}</span>


<span class="sd">        init_polynomial_coeffs(poly_idx_added)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order_begin: int</span>
<span class="sd">            order of polynomials to begin with</span>
<span class="sd">        order_end: int</span>
<span class="sd">            order of polynomials to end with</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">order_end</span><span class="o">-</span><span class="n">order_begin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">i_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_begin</span><span class="p">,</span> <span class="n">order_end</span><span class="p">):</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span>  <span class="c1"># beta-distr: alpha=p /// jacobi-poly: alpha=q-1  !!!</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span>  <span class="c1"># beta-distr: beta=q  /// jacobi-poly: beta=p-1   !!!</span>

                    <span class="c1"># determine polynomial normalization factor</span>
                    <span class="n">beta_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">jacobi_norm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">i_order</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">i_order</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> \
                                  <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">i_order</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">i_order</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                                                                      <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">i_order</span><span class="p">))</span>
                    <span class="c1"># initialize norm</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="n">i_order</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">jacobi_norm</span> <span class="o">*</span> <span class="n">beta_norm</span><span class="p">)</span>

                    <span class="c1"># add entry to polynomial lookup table</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">jacobi</span><span class="p">(</span><span class="n">i_order</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="n">i_order</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span><span class="p">:</span>
                    <span class="c1"># determine polynomial normalization factor</span>
                    <span class="n">hermite_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">i_order</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="n">i_order</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">hermite_norm</span>

                    <span class="c1"># add entry to polynomial lookup table</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">hermitenorm</span><span class="p">(</span><span class="n">i_order</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="n">i_order</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])</span></div>

<div class="viewcode-block" id="gPC.init_polynomial_basis"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.init_polynomial_basis">[docs]</a>    <span class="k">def</span> <span class="nf">init_polynomial_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize polynomial basis functions for a maximum order expansion.</span>

<span class="sd">        init_polynomial_basis()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate maximum order of polynomials</span>
        <span class="n">N_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>

        <span class="c1"># 2D list of polynomials (lookup)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># 2D array of polynomial normalization factors (lookup) [N_max+1 x dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>

        <span class="c1"># Setup list of polynomials and their coefficients up to the desired order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_polynomial_coeffs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.init_polynomial_basis_gpu"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.init_polynomial_basis_gpu">[docs]</a>    <span class="k">def</span> <span class="nf">init_polynomial_basis_gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialized polynomial basis coefficients for graphic card. Converts list of lists of self.polynomial_bases</span>
<span class="sd">        into np.ndarray that can be processed on a graphic card.</span>

<span class="sd">        init_polynomial_basis_gpu()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># transform list of lists of polynom objects into np.ndarray</span>
        <span class="n">number_of_variables</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">highest_degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">)</span>
        <span class="n">number_of_polynomial_coeffs</span> <span class="o">=</span> <span class="n">number_of_variables</span> <span class="o">*</span> <span class="p">(</span><span class="n">highest_degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">highest_degree</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_gpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">number_of_polynomial_coeffs</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">highest_degree</span><span class="p">):</span>
            <span class="n">degree_offset</span> <span class="o">=</span> <span class="n">number_of_variables</span> <span class="o">*</span> <span class="n">degree</span> <span class="o">*</span> <span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">single_degree_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">number_of_variables</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_variables</span><span class="p">):</span>
                <span class="n">single_degree_coeffs</span><span class="p">[:,</span> <span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_gpu</span><span class="p">[</span><span class="n">degree_offset</span><span class="p">:</span><span class="n">degree_offset</span> <span class="o">+</span> <span class="n">single_degree_coeffs</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_degree_coeffs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span>
                <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.init_polynomial_index"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.init_polynomial_index">[docs]</a>    <span class="k">def</span> <span class="nf">init_polynomial_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize polynomial multi indices. Determine 2D multi-index array (order) of basis functions and</span>
<span class="sd">        generate multi-index list up to maximum order. The size is [No. of basis functions x dim].</span>

<span class="sd">        .. math::</span>
<span class="sd">           \\begin{tabular}{l*{4}{c}}</span>
<span class="sd">            Polynomial Index    &amp; Dimension 1 &amp; Dimension 2 &amp; ... &amp; Dimension M \\\\</span>
<span class="sd">           \\hline</span>
<span class="sd">            Basis 1             &amp; [Order D1] &amp; [Order D2] &amp; \\vdots &amp; [Order M] \\\\</span>
<span class="sd">            Basis 2             &amp; [Order D1] &amp; [Order D2] &amp; \\vdots &amp; [Order M] \\\\</span>
<span class="sd">           \\vdots              &amp; [Order D1] &amp; [Order D2] &amp; \\vdots  &amp; [Order M] \\\\</span>
<span class="sd">            Basis N           &amp; [Order D1] &amp; [Order D2] &amp; \\vdots &amp; [Order M] \\\\</span>
<span class="sd">           \\end{tabular}</span>

<span class="sd">        init_polynomial_index()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="n">get_multi_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1"># add multi-indexes to list when not yet included</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span><span class="p">:</span>
                <span class="n">poly_add_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">poly_add_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">poly_add_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
                <span class="n">poly_add_all</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_add_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">,</span> <span class="n">poly_add_all</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)])</span>
            <span class="c1"># delete multi-indexes from list when they exceed individual max order of parameter     </span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="p">:]</span>

        <span class="c1"># Consider interaction order (filter out multi-indices exceeding it)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Convert to np.int32 for GPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx_gpu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># get size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># construct array of scaling factors to normalize basis functions &lt;psi^2&gt; = int(psi^2*p)dx</span>
        <span class="c1"># [N_poly_basis x 1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm_basis</span><span class="p">[</span><span class="n">i_poly</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">],</span> <span class="n">i_dim</span><span class="p">]</span></div>

<div class="viewcode-block" id="gPC.extend_polynomial_basis"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.extend_polynomial_basis">[docs]</a>    <span class="k">def</span> <span class="nf">extend_polynomial_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly_idx_added</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend polynomial basis functions and add new columns to gpc matrix.</span>

<span class="sd">        extend_polynomial_basis(poly_idx_added)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poly_idx_added: [N_poly_added x dim] np.ndarray</span>
<span class="sd">            array of added polynomials (order)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># determine if polynomials in poly_idx_added are already present in self.poly_idx if so, delete them</span>
        <span class="n">poly_idx_tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">new_row</span> <span class="ow">in</span> <span class="n">poly_idx_added</span><span class="p">:</span>
            <span class="n">not_in_poly_idx</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">new_row</span><span class="p">):</span>
                    <span class="n">not_in_poly_idx</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">not_in_poly_idx</span><span class="p">:</span>
                <span class="n">poly_idx_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>

        <span class="c1"># if all polynomials are already present end routine</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_idx_tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poly_idx_added</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">poly_idx_tmp</span><span class="p">)</span>

        <span class="c1"># determine highest order added        </span>
        <span class="n">order_max_added</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">poly_idx_added</span><span class="p">))</span>

        <span class="c1"># get current maximum order </span>
        <span class="n">order_max_current</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># preallocate new rows to polynomial lists</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_max_added</span> <span class="o">-</span> <span class="n">order_max_current</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)])</span>

        <span class="c1"># Extend list of polynomials and their coefficients up to the desired order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_polynomial_coeffs</span><span class="p">(</span><span class="n">order_max_current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order_max_added</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># append new multi-indexes to old poly_idx array</span>
        <span class="c1"># self.poly_idx = unique_rows(self.poly_idx)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">,</span> <span class="n">poly_idx_added</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># extend array of scaling factors to normalize basis functions &lt;psi^2&gt; = int(psi^2*p)dx</span>
        <span class="c1"># [N_poly_basis x 1]</span>
        <span class="n">N_poly_new</span> <span class="o">=</span> <span class="n">poly_idx_added</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">poly_norm_basis_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">N_poly_new</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_poly_new</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">poly_norm_basis_new</span><span class="p">[</span><span class="n">i_poly</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm</span><span class="p">[</span><span class="n">poly_idx_added</span><span class="p">[</span><span class="n">i_poly</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">],</span> <span class="n">i_dim</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poly_norm_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_norm_basis</span><span class="p">,</span> <span class="n">poly_norm_basis_new</span><span class="p">])</span>

        <span class="c1"># append new columns to gpc matrix [self.grid.coords.shape[0] x N_poly_new]</span>
        <span class="n">gpc_matrix_new_columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N_poly_new</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_poly_new</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_poly_new</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">gpc_matrix_new_columns</span><span class="p">[:,</span> <span class="n">i_poly_new</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">poly_idx_added</span><span class="p">[</span><span class="n">i_poly_new</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>\
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">])</span>

        <span class="c1"># append new column to gpc matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">,</span> <span class="n">gpc_matrix_new_columns</span><span class="p">])</span>

        <span class="c1"># invert gpc matrix gpc_matrix_inv [N_basis x self.grid.coords.shape[0]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.extend_gpc_matrix_samples"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.extend_gpc_matrix_samples">[docs]</a>    <span class="k">def</span> <span class="nf">extend_gpc_matrix_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples_poly_ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add sample points according to input pdfs to grid and extend the gpc matrix such that the ratio of</span>
<span class="sd">        rows/columns equals samples_poly_ratio.</span>

<span class="sd">        extend_gpc_matrix_samples(samples_poly_ratio, seed=None):</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples_poly_ratio: float</span>
<span class="sd">            ratio between number of samples and number of polynomials the matrix will be extended until</span>
<span class="sd">        seed: float, optional, default=None</span>
<span class="sd">            random seeding point</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Number of new grid points</span>
        <span class="n">N_grid_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">samples_poly_ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">N_grid_new</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Generate new grid points</span>
            <span class="n">new_grid_points</span> <span class="o">=</span> <span class="n">RandomGrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">,</span> <span class="n">N_grid_new</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

            <span class="c1"># append points to existing grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">,</span> <span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">])</span>

            <span class="c1"># determine new row of gpc matrix</span>
            <span class="n">gpc_matrix_new_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">N_grid_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">gpc_matrix_new_rows</span><span class="p">[:,</span> <span class="n">i_poly</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>\
                    <span class="p">(</span><span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">])</span>

            <span class="c1"># append new row to gpc matrix    </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">,</span> <span class="n">gpc_matrix_new_rows</span><span class="p">])</span>

            <span class="c1"># invert gpc matrix gpc_matrix_inv [N_basis x self.grid.coords.shape[0]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.replace_gpc_matrix_samples"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.replace_gpc_matrix_samples">[docs]</a>    <span class="k">def</span> <span class="nf">replace_gpc_matrix_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace distinct sample points from the gpc matrix.</span>

<span class="sd">        replace_gpc_matrix_samples(idx, seed=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx: np.ndarray</span>
<span class="sd">            array of grid indices of obj.grid.coords[idx,:] which are going to be replaced</span>
<span class="sd">            (rows of gPC matrix will be replaced by new ones)</span>
<span class="sd">        seed: float, optional, default=None</span>
<span class="sd">            random seeding point</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate new grid points</span>
        <span class="n">new_grid_points</span> <span class="o">=</span> <span class="n">RandomGrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># append points to existing grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords_norm</span>

        <span class="c1"># determine new row of gpc matrix</span>
        <span class="n">gpc_matrix_new_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">gpc_matrix_new_rows</span><span class="p">[:,</span> <span class="n">i_poly</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span> \
                    <span class="p">(</span><span class="n">new_grid_points</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">])</span>

        <span class="c1"># append new row to gpc matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">gpc_matrix_new_rows</span>

        <span class="c1"># invert gpc matrix gpc_matrix_inv [N_basis x self.grid.coords.shape[0]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.init_gpc_matrix"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.init_gpc_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">init_gpc_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the gPC matrix and  the Moore-Penrose-pseudo-inverse.</span>

<span class="sd">        init_gpc_matrix()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vprint</span><span class="p">(</span><span class="s1">&#39;Constructing gPC matrix ...&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">gpc_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpc_matrix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">gpc_matrix</span><span class="p">[:,</span> <span class="n">i_poly</span><span class="p">]</span> <span class="o">*=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span> <span class="o">=</span> <span class="n">gpc_matrix</span>

        <span class="k">def</span> <span class="nf">gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpc_matrix</span><span class="p">):</span>
            <span class="c1"># get parameters</span>
            <span class="n">number_of_variables</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">highest_degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">)</span>

            <span class="c1"># handle pointer</span>
            <span class="n">polynomial_coeffs_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_gpu</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">polynomial_index_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx_gpu</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
            <span class="n">xi_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">polynomial_matrix_pointer</span> <span class="o">=</span> <span class="n">gpc_matrix</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">number_of_psi_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">)</span>
            <span class="n">number_of_variables_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">number_of_variables</span><span class="p">)</span>
            <span class="n">highest_degree_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">highest_degree</span><span class="p">)</span>
            <span class="n">number_of_xi_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># handle shared object</span>
            <span class="n">dll</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;pckg&#39;</span><span class="p">,</span> <span class="s1">&#39;gpc.so&#39;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">RTLD_GLOBAL</span><span class="p">)</span>
            <span class="n">cuda_pce</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">polynomial_chaos_matrix</span>
            <span class="n">cuda_pce</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)]</span> <span class="o">+</span> \
                                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>

            <span class="c1"># evaluate CUDA implementation</span>
            <span class="n">cuda_pce</span><span class="p">(</span><span class="n">polynomial_coeffs_pointer</span><span class="p">,</span> <span class="n">polynomial_index_pointer</span><span class="p">,</span> <span class="n">xi_pointer</span><span class="p">,</span> <span class="n">polynomial_matrix_pointer</span><span class="p">,</span>
                     <span class="n">number_of_psi_size_t</span><span class="p">,</span> <span class="n">number_of_variables_size_t</span><span class="p">,</span> <span class="n">highest_degree_size_t</span><span class="p">,</span> <span class="n">number_of_xi_size_t</span><span class="p">)</span>

        <span class="c1"># choose between gpu or cpu execution</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpu</span><span class="p">:</span>
            <span class="n">cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpc_matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpc_matrix</span><span class="p">)</span>

        <span class="c1"># assign gpc matrix to member variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix</span> <span class="o">=</span> <span class="n">gpc_matrix</span>

        <span class="c1"># invert gpc matrix gpc_matrix_inv [N_basis x self.grid.coords.shape[0]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpc_matrix_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">gpc_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.get_mean_value"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_mean_value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_mean_value</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expected mean value.</span>

<span class="sd">        mean = get_mean_value(coeffs)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray</span>
<span class="sd">            gpc coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: [1 x N_out] np.ndarray</span>
<span class="sd">            expected mean value</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mean</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">mean</span></div>

<div class="viewcode-block" id="gPC.get_standard_deviation"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_standard_deviation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_standard_deviation</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the standard deviation.</span>

<span class="sd">        std = get_standard_deviation(coeffs)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: np.array of float [N_coeffs x N_out]</span>
<span class="sd">            gpc coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        std: [1 x N_out] np.ndarray</span>
<span class="sd">            standard deviation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">std</span></div>

<div class="viewcode-block" id="gPC.get_pdf_monte_carlo"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_pdf_monte_carlo">[docs]</a>    <span class="k">def</span> <span class="nf">get_pdf_monte_carlo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N_samples</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly sample the gPC expansion to determine output pdfs in specific points.</span>

<span class="sd">        xi = get_pdf_mc(N_samples, coeffs=None, output_idx=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N_samples: int</span>
<span class="sd">            number of random samples drawn from the respective input pdfs</span>
<span class="sd">        output_idx: [1 x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            idx of output quantities to consider</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            gPC coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xi: [N_samples x dim] np.ndarray</span>
<span class="sd">            generated samples in normalized coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># handle input parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffs</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpc_coeffs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># seed the random numbers generator</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span>

        <span class="c1"># generate random samples for each random input variable [N_samples x dim]</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span>
                <span class="n">xi</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">],</span> <span class="p">[</span><span class="n">N_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
                <span class="n">xi</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">N_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO: pce necessary?</span>
        <span class="c1"># if output index list is not provided, sample all gpc outputs</span>
        <span class="c1"># if not output_idx:</span>
            <span class="c1"># output_idx = np.linspace(0, self.N_out - 1, self.N_out)</span>
            <span class="c1"># output_idx = output_idx[np.newaxis, :]</span>
        <span class="c1"># pce = self.evaluate(coeffs, xi, output_idx)</span>
        <span class="c1"># return xi, pce</span>

        <span class="k">return</span> <span class="n">xi</span></div>

<div class="viewcode-block" id="gPC.get_pce"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_pce">[docs]</a>    <span class="k">def</span> <span class="nf">get_pce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the gPC approximation in points with output_idx and normalized parameters xi (interval: [-1, 1]).</span>

<span class="sd">        pce = get_pce(coeffs=None, xi=None, output_idx=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            gpc coefficients</span>
<span class="sd">        xi: [1 x dim] np.ndarray, optional, default=None</span>
<span class="sd">            point in variable space to evaluate local sensitivity in normalized coordinates</span>
<span class="sd">        output_idx: [1 x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            idx of output quantities to consider (Default: all outputs)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pce: [N_xi x N_out] np.ndarray</span>
<span class="sd">            gpc approximation at normalized coordinates xi</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        pce = get_pce([[xi_1_p1 ... xi_dim_p1] ,[xi_1_p2 ... xi_dim_p2]], np.array([[0,5,13]]))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">cpu</span><span class="p">():</span>
            <span class="n">pce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">):</span>
                <span class="n">gpc_matrix_new_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">gpc_matrix_new_row</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">](</span><span class="n">xi</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">])</span>
                <span class="n">pce</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">gpc_matrix_new_row</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i_poly</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">return</span> <span class="n">pce</span>

        <span class="k">def</span> <span class="nf">gpu</span><span class="p">():</span>
            <span class="c1"># initialize matrices and parameters</span>
            <span class="n">pce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">number_of_variables</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">highest_degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">)</span>

            <span class="c1"># handle pointer</span>
            <span class="n">polynomial_coeffs_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_gpu</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">polynomial_index_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx_gpu</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
            <span class="n">xi_pointer</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">sim_result_pointer</span> <span class="o">=</span> <span class="n">pce</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">sim_coeffs_pointer</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
            <span class="n">number_of_xi_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">number_of_variables_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">number_of_variables</span><span class="p">)</span>
            <span class="n">number_of_psi_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">highest_degree_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">highest_degree</span><span class="p">)</span>
            <span class="n">number_of_result_vectors_size_t</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># handle shared object</span>
            <span class="n">dll</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;pckg&#39;</span><span class="p">,</span> <span class="s1">&#39;pce.so&#39;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">RTLD_GLOBAL</span><span class="p">)</span>
            <span class="n">cuda_pce</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">polynomial_chaos_matrix</span>
            <span class="n">cuda_pce</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)]</span> <span class="o">+</span> \
                                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>

            <span class="c1"># evaluate CUDA implementation</span>
            <span class="n">cuda_pce</span><span class="p">(</span><span class="n">polynomial_coeffs_pointer</span><span class="p">,</span> <span class="n">polynomial_index_pointer</span><span class="p">,</span> <span class="n">xi_pointer</span><span class="p">,</span> <span class="n">sim_result_pointer</span><span class="p">,</span>
                     <span class="n">sim_coeffs_pointer</span><span class="p">,</span> <span class="n">number_of_psi_size_t</span><span class="p">,</span> <span class="n">number_of_result_vectors_size_t</span><span class="p">,</span>
                     <span class="n">number_of_variables_size_t</span><span class="p">,</span>
                     <span class="n">highest_degree_size_t</span><span class="p">,</span> <span class="n">number_of_xi_size_t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pce</span>

        <span class="c1"># handle input parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffs</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpc_coeffs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xi</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords_norm</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">output_idx</span><span class="p">):</span>
            <span class="n">output_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">output_idx</span> <span class="o">=</span> <span class="n">output_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[:,</span> <span class="n">output_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpu</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cpu</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gpu</span><span class="p">()</span></div>

<div class="viewcode-block" id="gPC.get_sobol_indices"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_sobol_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the available sobol indices.</span>

<span class="sd">        sobol, sobol_idx = get_sobol_indices(coeffs=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            gpc coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sobol: [N_sobol x N_out] np.ndarray</span>
<span class="sd">            unnormalized sobol_indices</span>
<span class="sd">        sobol_idx: list of [N_sobol x dim] np.ndarray</span>
<span class="sd">            list containing the parameter combinations in rows of sobol</span>
<span class="sd">        sobol_idx_bool: list of np.ndarray of bool</span>
<span class="sd">            boolean mask that determines which multi indices are unique</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;Determining Sobol indices&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># handle input parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffs</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpc_coeffs</span>
        <span class="n">N_coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">N_coeffs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Number of coefficients is 1 ... no sobol indices to calculate ...&#39;</span><span class="p">)</span>

        <span class="c1"># Generate boolean matrix of all basis functions where order &gt; 0 = True</span>
        <span class="c1"># size: [N_coeffs x dim] </span>
        <span class="n">sobol_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span> <span class="o">!=</span> <span class="mi">0</span>

        <span class="c1"># look for unique combinations (i.e. available sobol combinations)</span>
        <span class="c1"># size: [N_sobol x dim]</span>
        <span class="n">sobol_idx_bool</span> <span class="o">=</span> <span class="n">get_array_unique_rows</span><span class="p">(</span><span class="n">sobol_mask</span><span class="p">)</span>

        <span class="c1"># delete the first row where all polys are order 0 (no sensitivity)</span>
        <span class="n">sobol_idx_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sobol_idx_bool</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">N_sobol_available</span> <span class="o">=</span> <span class="n">sobol_idx_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># check which basis functions contribute to which sobol coefficient set </span>
        <span class="c1"># True for specific coeffs if it contributes to sobol coefficient</span>
        <span class="c1"># size: [N_coeffs x N_sobol]</span>
        <span class="n">sobol_poly_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_coeffs</span><span class="p">,</span> <span class="n">N_sobol_available</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_sobol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_sobol_available</span><span class="p">):</span>
            <span class="n">sobol_poly_idx</span><span class="p">[:,</span> <span class="n">i_sobol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sobol_mask</span> <span class="o">==</span> <span class="n">sobol_idx_bool</span><span class="p">[</span><span class="n">i_sobol</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># calculate sobol coefficients matrix by summing up the individual</span>
        <span class="c1"># contributions to the respective sobol coefficients</span>
        <span class="c1"># size [N_sobol x N_points]    </span>
        <span class="n">sobol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_sobol_available</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i_sobol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_sobol_available</span><span class="p">):</span>
            <span class="n">sobol</span><span class="p">[</span><span class="n">i_sobol</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">sobol_poly_idx</span><span class="p">[:,</span> <span class="n">i_sobol</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># sort sobol coefficients in descending order (w.r.t. first output only ...)</span>
        <span class="n">idx_sort_descend_1st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sobol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sobol</span> <span class="o">=</span> <span class="n">sobol</span><span class="p">[</span><span class="n">idx_sort_descend_1st</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">sobol_idx_bool</span> <span class="o">=</span> <span class="n">sobol_idx_bool</span><span class="p">[</span><span class="n">idx_sort_descend_1st</span><span class="p">]</span>

        <span class="c1"># get list of sobol indices</span>
        <span class="n">sobol_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sobol_idx_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i_sobol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sobol_idx_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sobol_idx</span><span class="p">[</span><span class="n">i_sobol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sobol_idx_bool</span><span class="p">[</span><span class="n">i_sobol</span><span class="p">,</span> <span class="p">:])</span> <span class="k">if</span> <span class="n">x</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">sobol</span><span class="p">,</span> <span class="n">sobol_idx</span><span class="p">,</span> <span class="n">sobol_idx_bool</span></div>

<div class="viewcode-block" id="gPC.write_log_sobol"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.write_log_sobol">[docs]</a>    <span class="k">def</span> <span class="nf">write_log_sobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">sobol_rel_order_mean</span><span class="p">,</span> <span class="n">sobol_rel_1st_order_mean</span><span class="p">,</span> <span class="n">sobol_extracted_idx_1st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write sobol indices into logfile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname: str</span>
<span class="sd">            path to output file</span>
<span class="sd">        sobol_rel_order_mean: np.ndarray</span>
<span class="sd">            average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,)</span>
<span class="sd">            over all output quantities</span>
<span class="sd">        sobol_rel_1st_order_mean: np.ndarray</span>
<span class="sd">            average proportion of the random variables of the 1st order Sobol indices to the total variance over all</span>
<span class="sd">            output quantities</span>
<span class="sd">        #TODO: add description</span>
<span class="sd">        sobol_extracted_idx_1st:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start log</span>
        <span class="n">log</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Sobol indices:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;==============</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># print order ratios</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Ratio: order / total variance over all output quantities:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;---------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sobol_rel_order_mean</span><span class="p">)):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Order </span><span class="si">{}</span><span class="s2">: </span><span class="si">{:.4f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sobol_rel_order_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># print 1st order ratios of parameters</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Ratio: 1st order Sobol indices of parameters / total variance over all output quantities</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;----------------------------------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">random_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">))])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sobol_rel_1st_order_mean</span><span class="p">)):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{:s}</span><span class="s2">: </span><span class="si">{:.4f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">sobol_extracted_idx_1st</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">sobol_extracted_idx_1st</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                <span class="n">sobol_rel_1st_order_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">random_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">sobol_extracted_idx_1st</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="n">log</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="gPC.get_sobol_order"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_sobol_order">[docs]</a>    <span class="k">def</span> <span class="nf">get_sobol_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sobol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sobol_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sobol_idx_bool</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate order of determined sobol indices.</span>

<span class="sd">        sobol, sobol_idx, sobol_rel_order_mean, sobol_rel_order_std, sobol_rel_1st_order_mean, sobol_rel_1st_order_std</span>
<span class="sd">        = get_sobol_order(coeffs=None, sobol=None, sobol_idx=None, sobol_idx_bool=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sobol: [N_sobol x N_out] np.ndarray</span>
<span class="sd">            unnormalized sobol_indices</span>
<span class="sd">        sobol_idx: list of [N_sobol x dim] np.ndarray</span>
<span class="sd">            list containing the parameter combinations in rows of sobol</span>
<span class="sd">        sobol_idx_bool: list of np.ndarray of bool</span>
<span class="sd">            boolean mask that determines which multi indices are unique</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sobol_rel_order_mean: np.ndarray</span>
<span class="sd">            average proportion of the Sobol indices of the different order to the total variance (1st, 2nd, etc..,)</span>
<span class="sd">            over all output quantities</span>
<span class="sd">        sobol_rel_order_std: np.ndarray</span>
<span class="sd">            standard deviation of the proportion of the Sobol indices of the different order to the total variance</span>
<span class="sd">            (1st, 2nd, etc..,) over all output quantities</span>
<span class="sd">        sobol_rel_1st_order_mean: np.ndarray</span>
<span class="sd">            average proportion of the random variables of the 1st order Sobol indices to the total variance over all</span>
<span class="sd">            output quantities</span>
<span class="sd">        sobol_rel_1st_order_std: np.ndarray</span>
<span class="sd">            standard deviation of the proportion of the random variables of the 1st order Sobol indices to the total</span>
<span class="sd">            variance over all output quantities</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get max order</span>
        <span class="n">order_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sobol_idx_bool</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># total variance</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sobol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># get NaN values</span>
        <span class="n">not_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>

        <span class="n">sobol_rel_order_mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sobol_rel_order_std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sobol_rel_1st_order_mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sobol_rel_1st_order_std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">str_out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get maximum length of random_vars label</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">))])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_max</span><span class="p">):</span>
            <span class="c1"># extract sobol coefficients of order i</span>
            <span class="n">sobol_extracted</span><span class="p">,</span> <span class="n">sobol_extracted_idx</span> <span class="o">=</span> <span class="n">get_extracted_sobol_order</span><span class="p">(</span><span class="n">sobol</span><span class="p">,</span> <span class="n">sobol_idx</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">sobol_rel_order_mean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sobol_extracted</span><span class="p">[:,</span> <span class="n">not_nan_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]))</span>
            <span class="n">sobol_rel_order_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Ratio: Sobol indices order </span><span class="si">{}</span><span class="s2"> / total variance: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sobol_rel_order_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># for first order indices, determine ratios of all random variables</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># deep copy</span>
                <span class="n">sobol_extracted_idx_1st</span> <span class="o">=</span> <span class="n">sobol_extracted_idx</span><span class="p">[:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sobol_extracted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">sobol_rel_1st_order_mean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sobol_extracted</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">not_nan_mask</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                                                    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]))</span>
                    <span class="n">sobol_rel_1st_order_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">str_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}{}</span><span class="s2">: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">max_len</span> <span class="o">-</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span>
                                                                    <span class="n">sobol_extracted_idx_1st</span><span class="p">[</span><span class="n">j</span><span class="p">]]))</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">random_vars</span><span class="p">[</span><span class="n">sobol_extracted_idx_1st</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
                                                           <span class="n">sobol_rel_1st_order_mean</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="n">sobol_rel_order_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sobol_rel_order_mean</span><span class="p">)</span>
        <span class="n">sobol_rel_1st_order_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sobol_rel_1st_order_mean</span><span class="p">)</span>

        <span class="c1"># print output of 1st order Sobol indice ratios of parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">str_out</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">str_out</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">sobol</span><span class="p">,</span> <span class="n">sobol_idx</span><span class="p">,</span> <span class="n">sobol_rel_order_mean</span><span class="p">,</span> <span class="n">sobol_rel_order_std</span><span class="p">,</span> <span class="n">sobol_rel_1st_order_mean</span><span class="p">,</span>\
               <span class="n">sobol_rel_1st_order_std</span></div>

<div class="viewcode-block" id="gPC.get_global_sens"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_global_sens">[docs]</a>    <span class="k">def</span> <span class="nf">get_global_sens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the global derivative based sensitivity coefficients.</span>

<span class="sd">        Reference:</span>
<span class="sd">        D. Xiu, Fast Numerical Methods for Stochastic Computations: A Review,</span>
<span class="sd">        Commun. Comput. Phys., 5 (2009), pp. 242-272 eq. (3.14) page 255</span>

<span class="sd">        get_global_sens = calc_globalsens(coeffs)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray</span>
<span class="sd">            gpc coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        get_global_sens: [dim x N_out] np.ndarray</span>
<span class="sd">            global derivative based sensitivity coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span><span class="p">)]</span>
        <span class="n">poly_der_int</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span><span class="p">)]</span>
        <span class="n">poly_int</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span><span class="p">)]</span>
        <span class="n">knots_list_1d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="n">weights_list_1d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>

        <span class="c1"># generate quadrature points for numerical integration for each random</span>
        <span class="c1"># variable separately (2*N_max points for high accuracy)</span>

        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span>  <span class="c1"># Jacobi polynomials</span>
                <span class="n">knots_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="n">weights_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_quadrature_jacobi_1d</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_max</span><span class="p">,</span>
                                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>  <span class="c1"># Hermite polynomials</span>
                <span class="n">knots_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="n">weights_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_quadrature_hermite_1d</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_max</span><span class="p">)</span>

        <span class="c1"># pre-process polynomials</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span><span class="p">):</span>
                <span class="c1"># evaluate the derivatives of the polynomials</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span>

                <span class="c1"># evaluate poly and poly_der at quadrature points and integrate w.r.t.</span>
                <span class="c1"># pdf (multiply with weights and sum up)</span>
                <span class="c1"># saved like self.poly [N_order x dim]</span>
                <span class="n">poly_int</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">](</span><span class="n">knots_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]),</span> <span class="n">weights_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]))</span>
                <span class="n">poly_der_int</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">](</span><span class="n">knots_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]),</span> <span class="n">weights_list_1d</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]))</span>

        <span class="n">N_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">poly_der_int_multi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">N_poly</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i_sens</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_poly</span><span class="p">):</span>
                <span class="n">poly_der_int_single</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># evaluate complete integral (joint basis function)                </span>
                <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i_dim</span> <span class="o">==</span> <span class="n">i_sens</span><span class="p">:</span>
                        <span class="n">poly_der_int_single</span> <span class="o">*=</span> <span class="n">poly_der_int</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">poly_der_int_single</span> <span class="o">*=</span> <span class="n">poly_int</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>

                <span class="n">poly_der_int_multi</span><span class="p">[</span><span class="n">i_sens</span><span class="p">,</span> <span class="n">i_poly</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_der_int_single</span>

        <span class="c1"># sum up over all coefficients        </span>
        <span class="c1"># [dim x N_points]  = [dim x N_poly] * [N_poly x N_points]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly_der_int_multi</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.get_local_sens"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_local_sens">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_sens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the local derivative based sensitivity coefficients in the point of operation xi</span>
<span class="sd">        in normalized coordinates.</span>

<span class="sd">        get_local_sens = calc_localsens(coeffs, xi)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray</span>
<span class="sd">            gpc coefficients</span>
<span class="sd">        xi: [N_coeffs x N_out] np.ndarray</span>
<span class="sd">            point in variable space to evaluate local sensitivity in (normalized coordinates!)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        get_local_sens: [dim x N_out] np.ndarray</span>
<span class="sd">            local sensitivity</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N_max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">poly_der_xi</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">poly_opvals</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># pre-process polynomials</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># evaluate the derivatives of the polynomials</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span>

                <span class="c1"># evaluate poly and poly_der at point of operation</span>
                <span class="n">poly_opvals</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">](</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])</span>
                <span class="n">poly_der_xi</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_der</span><span class="p">[</span><span class="n">i_order</span><span class="p">][</span><span class="n">i_dim</span><span class="p">](</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])</span>

        <span class="n">N_vals</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">poly_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i_sens</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_poly</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_poly</span><span class="p">):</span>
                <span class="n">poly_sens_single</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_vals</span><span class="p">)</span>

                <span class="c1"># construct polynomial basis according to partial derivatives                </span>
                <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i_dim</span> <span class="o">==</span> <span class="n">i_sens</span><span class="p">:</span>
                        <span class="n">poly_sens_single</span> <span class="o">*=</span> <span class="n">poly_der_xi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">poly_sens_single</span> <span class="o">*=</span> <span class="n">poly_opvals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_idx</span><span class="p">[</span><span class="n">i_poly</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]][</span><span class="n">i_dim</span><span class="p">]</span>
                <span class="n">poly_sens</span><span class="p">[</span><span class="n">i_sens</span><span class="p">,</span> <span class="n">i_poly</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_sens_single</span>

        <span class="c1"># sum up over all coefficients        </span>
        <span class="c1"># [dim x N_points]  = [dim x N_poly]  *   [N_poly x N_points]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly_sens</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span></div>

<div class="viewcode-block" id="gPC.get_pdf"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_pdf">[docs]</a>    <span class="k">def</span> <span class="nf">get_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">N_samples</span><span class="p">,</span> <span class="n">output_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine the estimated pdfs of the output quantities</span>

<span class="sd">        pdf_x, pdf_y = get_pdf(coeffs, N_samples, output_idx=None)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeffs: [N_coeffs x N_out] np.ndarray</span>
<span class="sd">            gpc coefficients</span>
<span class="sd">        N_samples: int</span>
<span class="sd">            number of samples used to estimate output pdf</span>
<span class="sd">        output_idx: [1 x N_out] np.ndarray, optional, default=None</span>
<span class="sd">            idx of output quantities to consider</span>
<span class="sd">            if output_idx=None, all output quantities are considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf_x: [100 x N_out] np.ndarray</span>
<span class="sd">            x-coordinates of output pdf (output quantity),</span>
<span class="sd">        pdf_y: [100 x N_out] np.ndarray</span>
<span class="sd">            y-coordinates of output pdf (probability density of output quantity)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if output index array is not provided, determine pdfs of all outputs </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_idx</span><span class="p">:</span>
            <span class="n">output_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span><span class="p">)</span>
            <span class="n">output_idx</span> <span class="o">=</span> <span class="n">output_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># sample gPC expansion</span>
        <span class="n">samples_in</span><span class="p">,</span> <span class="n">samples_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pdf_mc</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">N_samples</span><span class="p">,</span> <span class="n">output_idx</span><span class="p">)</span>

        <span class="c1"># determine kernel density estimates using Gaussian kernel</span>
        <span class="n">pdf_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span><span class="p">])</span>
        <span class="n">pdf_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_out</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i_out</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">samples_out</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">bw_method</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">/</span> <span class="n">samples_out</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">pdf_x</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">samples_out</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples_out</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">pdf_y</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">kde</span><span class="p">(</span><span class="n">pdf_x</span><span class="p">[:,</span> <span class="n">i_out</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">pdf_x</span><span class="p">,</span> <span class="n">pdf_y</span></div>

<div class="viewcode-block" id="gPC.get_mean_random_vars"><a class="viewcode-back" href="../../pygpc.gpc.html#pygpc.gpc.gPC.get_mean_random_vars">[docs]</a>    <span class="k">def</span> <span class="nf">get_mean_random_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the average values of the input random variables from their pdfs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean_random_vars: [N_random_vars] np.ndarray</span>
<span class="sd">            average values of the input random variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean_random_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">mean_random_vars</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span>
                <span class="n">mean_random_vars</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span> <span class="o">/</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]))</span> <span class="o">*</span> \
                                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span> <span class="o">+</span> \
                                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">mean_random_vars</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pygpc</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Konstantin Weise, Benjamin Kalloch, Lucas Possner.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>