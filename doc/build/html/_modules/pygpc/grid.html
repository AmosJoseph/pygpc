
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pygpc.grid &#8212; pygpc 2018 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pygpc.grid</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions and classes that provide data and methods for the generation and processing of numerical grids</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>

<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.extmath</span> <span class="k">import</span> <span class="n">cartesian</span>
<span class="kn">from</span> <span class="nn">.misc</span> <span class="k">import</span> <span class="n">get_multi_indices</span>
<span class="kn">from</span> <span class="nn">.misc</span> <span class="k">import</span> <span class="n">vprint</span>


<div class="viewcode-block" id="get_quadrature_jacobi_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_jacobi_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_jacobi_1d</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get knots and weights of Jacobi polynomials (beta distribution).</span>

<span class="sd">    knots, weights = get_quadrature_jacobi_1d(N, b, a)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>
<span class="sd">    a: float</span>
<span class="sd">        lower limit of quadrature coefficients</span>
<span class="sd">    b: float</span>
<span class="sd">        upper limit of quadrature coefficients</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make array to count N: 0, 1, ..., N-1</span>
    <span class="n">N_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># compose diagonals for companion matrix</span>
    <span class="n">t01</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">t02</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t01</span><span class="p">,</span> <span class="n">t02</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_arr</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_arr</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_arr</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_arr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))</span>

    <span class="c1"># compose companion matrix</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># evaluate roots of polynomials (the abscissas are the roots of the</span>
    <span class="c1"># characteristic polynomial, i.d. the eigenvalues of the companion matrix)</span>
    <span class="c1"># the weights can be derived from the corresponding eigenvectors.</span>
    <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">idx_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>
    <span class="n">eigvals_sorted</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="n">idx_sorted</span><span class="p">]</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">eigvecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_sorted</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">knots</span> <span class="o">=</span> <span class="n">eigvals_sorted</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_quadrature_hermite_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_hermite_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_hermite_1d</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get knots and weights of Hermite polynomials (normal distribution).</span>

<span class="sd">    knots, weights = get_quadrature_hermite_1d(N)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">hermite_e</span><span class="o">.</span><span class="n">hermegauss</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_quadrature_clenshaw_curtis_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_clenshaw_curtis_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_clenshaw_curtis_1d</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the Clenshaw Curtis nodes and weights.</span>

<span class="sd">    knots, weights = get_quadrature_clenshaw_curtis_1d(N)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">C</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">))</span>
        <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">C</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="p">:])))</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifft</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_quadrature_fejer1_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_fejer1_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_fejer1_1d</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Fejer type 1 nodes and weights.</span>
<span class="sd">    </span>
<span class="sd">    This method uses a direct approach. The paper by Waldvogel</span>
<span class="sd">    exhibits a more efficient approach using Fourier transforms.</span>

<span class="sd">    Reference:</span>
<span class="sd">    Philip Davis, Philip Rabinowitz,</span>
<span class="sd">    Methods of Numerical Integration,</span>
<span class="sd">    Second Edition,</span>
<span class="sd">    Dover, 2007,</span>
<span class="sd">    ISBN: 0486453391 Titel anhand dieser ISBN in Citavi-Projekt übernehmen,</span>
<span class="sd">    LC: QA299.3.D28.</span>

<span class="sd">    Walter Gautschi,</span>
<span class="sd">    Numerical Quadrature in the Presence of a Singularity,</span>
<span class="sd">    SIAM Journal on Numerical Analysis,</span>
<span class="sd">    Volume 4, Number 3, 1967, pages 357-362.</span>

<span class="sd">    Joerg Waldvogel,</span>
<span class="sd">    Fast Construction of the Fejer and Clenshaw-Curtis Quadrature Rules,</span>
<span class="sd">    BIT Numerical Mathematics,</span>
<span class="sd">    Volume 43, Number 1, 2003, pages 1-18.</span>

<span class="sd">    knots, weights = get_quadrature_fejer1_1d(N)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">jhi</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jhi</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_quadrature_fejer2_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_fejer2_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_fejer2_1d</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Fejer type 2 nodes and weights (Clenshaw Curtis without boundary nodes).</span>
<span class="sd">        </span>
<span class="sd">    This method uses a direct approach. The paper by Waldvogel</span>
<span class="sd">    exhibits a more efficient approach using Fourier transforms.</span>

<span class="sd">    Reference:</span>
<span class="sd">    Philip Davis, Philip Rabinowitz,</span>
<span class="sd">    Methods of Numerical Integration,</span>
<span class="sd">    Second Edition,</span>
<span class="sd">    Dover, 2007,</span>
<span class="sd">    ISBN: 0486453391 Titel anhand dieser ISBN in Citavi-Projekt übernehmen,</span>
<span class="sd">    LC: QA299.3.D28.</span>

<span class="sd">    Walter Gautschi,</span>
<span class="sd">    Numerical Quadrature in the Presence of a Singularity,</span>
<span class="sd">    SIAM Journal on Numerical Analysis,</span>
<span class="sd">    Volume 4, Number 3, 1967, pages 357-362.</span>

<span class="sd">    Joerg Waldvogel,</span>
<span class="sd">    Fast Construction of the Fejer and Clenshaw-Curtis Quadrature Rules,</span>
<span class="sd">    BIT Numerical Mathematics,</span>
<span class="sd">    Volume 43, Number 1, 2003, pages 1-18.</span>

<span class="sd">    knots, weights = get_quadrature_fejer2_1d(N)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

        <span class="n">knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>

            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">jhi</span> <span class="o">=</span> <span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jhi</span><span class="p">):</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_quadrature_patterson_1d"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_quadrature_patterson_1d">[docs]</a><span class="k">def</span> <span class="nf">get_quadrature_patterson_1d</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the nested Gauss-Patterson nodes and weights for N = 1,3,7,15,31.</span>

<span class="sd">    knots, weights = get_quadrature_patterson_1d(N)</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    N: int</span>
<span class="sd">        number of knots</span>
<span class="sd">        possible values: 1, 3, 7, 15, 31</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: np.ndarray</span>
<span class="sd">        knots of the grid</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span>

    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.77459666924148337704</span>

        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.555555555555555555556</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.888888888888888888889</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.555555555555555555556</span>

    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.96049126870802028342</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.96049126870802028342</span>

        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.104656226026467265194</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.268488089868333440729</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.401397414775962222905</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.450916538658474142345</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.401397414775962222905</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.268488089868333440729</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.104656226026467265194</span>

    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">15</span><span class="p">:</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.99383196321275502221</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.96049126870802028342</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.88845923287225699889</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.62110294673722640294</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.22338668642896688163</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.22338668642896688163</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.62110294673722640294</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.88845923287225699889</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.96049126870802028342</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99383196321275502221</span>

        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0170017196299402603390</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0516032829970797396969</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0929271953151245376859</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.134415255243784220360</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.171511909136391380787</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.200628529376989021034</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.219156858401587496404</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.225510499798206687386</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.219156858401587496404</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.200628529376989021034</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.171511909136391380787</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.134415255243784220360</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0929271953151245376859</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0516032829970797396969</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0170017196299402603390</span>

    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">31</span><span class="p">:</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.99909812496766759766</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.99383196321275502221</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.98153114955374010687</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.96049126870802028342</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.92965485742974005667</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.88845923287225699889</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.83672593816886873550</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.70249620649152707861</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.62110294673722640294</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.53131974364437562397</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.33113539325797683309</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.22338668642896688163</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.11248894313318662575</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.11248894313318662575</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.22338668642896688163</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.33113539325797683309</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.43424374934680255800</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.53131974364437562397</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.62110294673722640294</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.70249620649152707861</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.77459666924148337704</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.83672593816886873550</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.88845923287225699889</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.92965485742974005667</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.96049126870802028342</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.98153114955374010687</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99383196321275502221</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99909812496766759766</span>

        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00254478079156187441540</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00843456573932110624631</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0164460498543878109338</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0258075980961766535646</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0359571033071293220968</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0464628932617579865414</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0569795094941233574122</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0672077542959907035404</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0768796204990035310427</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0857559200499903511542</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0936271099812644736167</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.100314278611795578771</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.105669893580234809744</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.109578421055924638237</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.111956873020953456880</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.112755256720768691607</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.111956873020953456880</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.109578421055924638237</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.105669893580234809744</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.100314278611795578771</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0936271099812644736167</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0857559200499903511542</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0768796204990035310427</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0672077542959907035404</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0569795094941233574122</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0464628932617579865414</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0359571033071293220968</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0258075980961766535646</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0164460498543878109338</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00843456573932110624631</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00254478079156187441540</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of points does not match Gauss-Patterson quadrature rule.&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">knots</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">return</span> <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="get_denormalized_coordinates"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_denormalized_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_denormalized_coordinates</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">,</span> <span class="n">pdf_type</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denormalize grid from standardized ([-1, 1] except hermite) to original parameter space for simulations.</span>

<span class="sd">    coords = get_denormalized_coordinates(coords_norm, pdf_type, grid_shape, limits)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [dim] list of str</span>
<span class="sd">        type of pdf &#39;beta&#39; or &#39;norm&#39;</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    coords_norm: [N_samples x dim] np.ndarray</span>
<span class="sd">        normalized [-1, 1] coordinates xi</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coords: [N_samples x dim] np.ndarray</span>
<span class="sd">        denormalized coordinates xi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        
        <span class="c1"># if gridtype[i_dim] == &#39;jacobi&#39; or gridtype[i_dim] == &#39;cc&#39; or gridtype[i_dim] == &#39;fejer2&#39;:</span>
        <span class="k">if</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span> <span class="o">+</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                <span class="n">i_dim</span><span class="p">]</span>
        <span class="c1"># if gridtype[i_dim] == &#39;hermite&#39;:</span>
        <span class="k">if</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">coords</span></div>


<div class="viewcode-block" id="get_normalized_coordinates"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.get_normalized_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_normalized_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">pdf_type</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize grid from original parameter (except hermite) to standardized ([-1, 1] space for simulations.</span>

<span class="sd">    coords_norm = get_normalized_coordinates(coords, pdf_type, grid_shape, limits)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [dim] list of str</span>
<span class="sd">        type of pdf &#39;beta&#39; or &#39;norm&#39;</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    coords: [N_samples x dim] np.ndarray</span>
<span class="sd">        denormalized coordinates xi</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coords_norm: [N_samples x dim] np.ndarray</span>
<span class="sd">        normalized [-1, 1] coordinates xi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        
        <span class="c1"># if gridtype[i_dim] == &#39;jacobi&#39; or gridtype[i_dim] == &#39;cc&#39; or gridtype[i_dim] == &#39;fejer2&#39;:</span>
        <span class="k">if</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span>
            <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span>
            <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># if gridtype[i_dim] == &#39;hermite&#39;:</span>
        <span class="k">if</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">])</span> <span class="o">/</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">coords_norm</span></div>


<div class="viewcode-block" id="TensorGrid"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.TensorGrid">[docs]</a><span class="k">class</span> <span class="nc">TensorGrid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate TensorGrid object instance.</span>

<span class="sd">    Initialisation</span>
<span class="sd">    --------------</span>
<span class="sd">    TensorGrid(pdf_type, grid_type, grid_shape, limits, N):</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of PDF (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_type: [N_vars] list of str</span>
<span class="sd">        specify type of quadrature used to construct sparse grid (&#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    N: [N_vars] list of int</span>
<span class="sd">        number of nodes in each dimension</span>
<span class="sd">    dim: int</span>
<span class="sd">        number of uncertain parameters to process</span>
<span class="sd">    knots_dim_list: [dim] list of np.ndarray</span>
<span class="sd">        knots of grid in each dimension</span>
<span class="sd">    weights_dim_list: [dim] list of np.ndarray</span>
<span class="sd">        weights of grid in each dimension</span>
<span class="sd">    coords_norm: [N_samples x dim] np.ndarray</span>
<span class="sd">        normalized [-1, 1] coordinates xi</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    coords: [N_samples x dim] np.ndarray</span>
<span class="sd">        denormalized coordinates xi</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of PDF (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_type: [N_vars] list of str</span>
<span class="sd">        specify type of quadrature used to construct sparse grid (&#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    N: [N_vars] list of int</span>
<span class="sd">        number of nodes in each dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_type</span><span class="p">,</span> <span class="n">grid_type</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span> <span class="o">=</span> <span class="n">pdf_type</span>  <span class="c1"># &#39;beta&#39;, &#39;normal&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">=</span> <span class="n">grid_type</span>  <span class="c1"># &#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid_shape</span>  <span class="c1"># pdf_shape: jacobi: -&gt; [alpha, beta] hermite: -&gt; [mean, std]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span>  <span class="c1"># limits: [min, max]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>  <span class="c1"># number of nodes in each dimension [dim x 1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># number of dimension</span>

        <span class="c1"># get knots and weights of polynomials in each dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knots_dim_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_dim_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;jacobi&#39;</span><span class="p">:</span>  <span class="c1"># jacobi polynomials</span>
                <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">get_quadrature_jacobi_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hermite&#39;</span><span class="p">:</span>  <span class="c1"># hermite polynomials</span>
                <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">get_quadrature_hermite_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i_dim</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;clenshaw_curtis&#39;</span><span class="p">:</span>  <span class="c1"># Clenshaw Curtis</span>
                <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">get_quadrature_clenshaw_curtis_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i_dim</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">:</span>  <span class="c1"># Fejer type 2 (Clenshaw Curtis without boundary nodes)</span>
                <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">get_quadrature_fejer2_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i_dim</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;patterson&#39;</span><span class="p">:</span>  <span class="c1"># Gauss-Patterson (Nested Legendre rule)</span>
                <span class="n">knots</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">get_quadrature_patterson_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i_dim</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">knots_dim_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_dim_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># combine coordinates to full tensored grid (all combinations)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span> <span class="o">=</span> <span class="n">cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots_dim_list</span><span class="p">)</span>

        <span class="c1"># rescale normalized coordinates in case of normal distributions and &quot;fejer2&quot; or &quot;cc&quot; grids</span>
        <span class="c1"># +- 0.675 * sigma -&gt; 50%</span>
        <span class="c1"># +- 1.645 * sigma -&gt; 90%</span>
        <span class="c1"># +- 1.960 * sigma -&gt; 95%        </span>
        <span class="c1"># +- 2.576 * sigma -&gt; 99%</span>
        <span class="c1"># +- 3.000 * sigma -&gt; 99.73%</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;hermite&quot;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.960</span>

        <span class="c1"># determine combined weights of Gauss quadrature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights_dim_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c1"># denormalize grid to original parameter space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">get_denormalized_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span></div>


<span class="c1"># TODO: grid_shape[1] of norm is now STD. Check if code changes in sparse.</span>
<div class="viewcode-block" id="SparseGrid"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid">[docs]</a><span class="k">class</span> <span class="nc">SparseGrid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate SparseGrid object instance.</span>

<span class="sd">    Initialisation</span>
<span class="sd">    --------------</span>
<span class="sd">    SparseGrid(pdf_type, grid_type, grid_shape, limits, level, level_max, interaction_order,</span>
<span class="sd">               order_sequence_type, make_grid=True, verbose=True)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of PDF (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_type: [N_vars] list of str</span>
<span class="sd">        specify type of quadrature used to construct sparse grid (&#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    level: [N_vars] list of int</span>
<span class="sd">        number of levels in each dimension</span>
<span class="sd">    level_max: int</span>
<span class="sd">        global combined level maximum</span>
<span class="sd">    interaction_order: int</span>
<span class="sd">        interaction order of parameters and grid, i.e. the grid points are lying between this number of dimensions</span>
<span class="sd">    order_sequence_type: str</span>
<span class="sd">        type of order sequence (&#39;lin&#39;, &#39;exp&#39;) common: &#39;exp&#39;</span>
<span class="sd">    make_grid: boolean</span>
<span class="sd">        boolean value to determine if to generate grid during initialization</span>
<span class="sd">    verbose: bool</span>
<span class="sd">        boolean value to determine if to print out the progress into the standard output</span>
<span class="sd">    coords_norm: [N_samples x dim] np.ndarray</span>
<span class="sd">        normalized [-1, 1] coordinates xi</span>
<span class="sd">    weights: np.ndarray</span>
<span class="sd">        weights of the grid</span>
<span class="sd">    coords: [N_samples x dim] np.ndarray</span>
<span class="sd">        denormalized coordinates xi</span>
<span class="sd">    level_sequence: list of int</span>
<span class="sd">        list containing the levels</span>
<span class="sd">    order_sequence: list of int</span>
<span class="sd">        list containing the polynomial order of the levels</span>
<span class="sd">    dim: int</span>
<span class="sd">        number of uncertain parameters to process</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of PDF (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_type: [N_vars] list of str</span>
<span class="sd">        specify type of quadrature used to construct sparse grid (&#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    level: [N_vars] list of int</span>
<span class="sd">        number of levels in each dimension</span>
<span class="sd">    level_max: int</span>
<span class="sd">        global combined level maximum</span>
<span class="sd">    interaction_order: int</span>
<span class="sd">        interaction order of parameters and grid, i.e. the grid points are lying between this number of dimensions</span>
<span class="sd">    order_sequence_type: str</span>
<span class="sd">        type of order sequence (&#39;lin&#39;, &#39;exp&#39;) common: &#39;exp&#39;</span>
<span class="sd">    make_grid: boolean, optional, default=True</span>
<span class="sd">        boolean value to determine if to generate grid during initialization</span>
<span class="sd">    verbose: bool, optional, default=True</span>
<span class="sd">        boolean value to determine if to print out the progress into the standard output</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_type</span><span class="p">,</span> <span class="n">grid_type</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_max</span><span class="p">,</span> <span class="n">interaction_order</span><span class="p">,</span>
                 <span class="n">order_sequence_type</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span> <span class="o">=</span> <span class="n">pdf_type</span>  <span class="c1"># &#39;beta&#39;, &#39;normal&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">=</span> <span class="n">grid_type</span>  <span class="c1"># &#39;jacobi&#39;, &#39;hermite&#39;, &#39;cc&#39;, &#39;fejer2&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid_shape</span>  <span class="c1"># pdfshape: jacobi: -&gt; [alpha and beta], hermite: -&gt; [mean, variance]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span>  <span class="c1"># limits: [min, max]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>  <span class="c1"># number of levels in each dimension [dim x 1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span> <span class="o">=</span> <span class="n">level_max</span>  <span class="c1"># global combined level maximum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span> <span class="o">=</span> <span class="n">interaction_order</span>  <span class="c1"># interaction order of parameters and grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence_type</span> <span class="o">=</span> <span class="n">order_sequence_type</span>  <span class="c1"># &#39;lin&#39;, &#39;exp&#39; type of order sequence (common: &#39;exp&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>  <span class="c1"># output while grid generation on/off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>  <span class="c1"># number of dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># coordinates of gpc model calculation in the system space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># coordinates of gpc model calculation in the gpc space [-1,1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># weights for numerical integration for every point in the coordinate space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_sequence</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># integer sequence of levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># integer sequence of polynom order of levels</span>

        <span class="c1"># grid is generated during initialization or coords, coords_norm and weights are added manually</span>
        <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_multi_index_lst</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_coords_weights</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse grid initialized but not generated. Please add coords / coords_norm and weights manually.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SparseGrid.calc_multi_index_lst"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid.calc_multi_index_lst">[docs]</a>    <span class="k">def</span> <span class="nf">calc_multi_index_lst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the multi index list needed for the calculation of the SparseGrid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">level_sequence</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">level_sequence</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence_type</span> <span class="o">==</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span>  <span class="c1"># order = 2**level + 1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">:</span>  <span class="c1"># start with order = 1 @ level = 1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;patterson&#39;</span><span class="p">:</span>  <span class="c1"># start with order = 1 @ level = 0 [1,3,7,15,31,...]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># start with order = 1 @ level = 0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence_type</span> <span class="o">==</span> <span class="s1">&#39;lin&#39;</span><span class="p">:</span>  <span class="c1"># order = level</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">:</span>  <span class="c1"># start with level = 1 @ order = 1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;patterson&#39;</span><span class="p">:</span>  <span class="c1"># start with order = 1 @ level = 0 [1,3,7,15,31,...]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not possible in case of Gauss-Patterson grid.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># start with</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>

<div class="viewcode-block" id="SparseGrid.calc_l_level"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid.calc_l_level">[docs]</a>    <span class="k">def</span> <span class="nf">calc_l_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the l-level needed for the Fejer grid type 2.</span>

<span class="sd">        l_level = calc_l_level()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        l_level: np.ndarray</span>
<span class="sd">            multi indices filtered by level capacity and interaction order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;fejer2&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">get_multi_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">l_level</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">get_multi_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_max</span><span class="p">)</span>

        <span class="c1"># filter out rows exceeding the individual level cap</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">l_level</span> <span class="o">=</span> <span class="n">l_level</span><span class="p">[</span><span class="n">l_level</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]]</span>

        <span class="c1"># Consider interaction order (filter out multi-indices exceeding it)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;fejer2&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">):</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">l_level</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l_level</span> <span class="o">=</span> <span class="n">l_level</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_order</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">l_level</span></div>

<div class="viewcode-block" id="SparseGrid.calc_grid"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid.calc_grid">[docs]</a>    <span class="k">def</span> <span class="nf">calc_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate a cubature lookup table for knots and weights.</span>

<span class="sd">        dl_k, dl_w = calc_grid()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dl_k: list of list of float</span>
<span class="sd">            cubature lookup table for knots</span>
<span class="sd">        dl_w: list of list of float</span>
<span class="sd">            cubature lookup table for weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make cubature lookup table for knots (dl_k) and weights (dl_w) [max(l) x dim]</span>
        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;    Generating difference grids...&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">dl_k</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
        <span class="n">dl_w</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
        <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span><span class="p">,</span> <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">i_level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;jacobi&#39;</span><span class="p">:</span>  <span class="c1"># Jacobi polynomials</span>
                    <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span> <span class="o">=</span> <span class="n">get_quadrature_jacobi_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span><span class="p">],</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="n">get_quadrature_jacobi_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hermite&#39;</span><span class="p">:</span>  <span class="c1"># Hermite polynomials</span>
                    <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span> <span class="o">=</span> <span class="n">get_quadrature_hermite_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span><span class="p">])</span>
                    <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="n">get_quadrature_hermite_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;patterson&#39;</span><span class="p">:</span>  <span class="c1"># Gauss-Patterson</span>
                    <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span> <span class="o">=</span> <span class="n">get_quadrature_patterson_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span><span class="p">])</span>
                    <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="n">get_quadrature_patterson_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cc&#39;</span><span class="p">:</span>  <span class="c1"># Clenshaw Curtis</span>
                    <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span> <span class="o">=</span> <span class="n">get_quadrature_clenshaw_curtis_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span><span class="p">])</span>
                    <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="n">get_quadrature_clenshaw_curtis_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">:</span>  <span class="c1"># Fejer type 2</span>
                    <span class="n">knots_l</span><span class="p">,</span> <span class="n">weights_l</span> <span class="o">=</span> <span class="n">get_quadrature_fejer2_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">knots_l_1</span><span class="p">,</span> <span class="n">weights_l_1</span> <span class="o">=</span> <span class="n">get_quadrature_fejer2_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_sequence</span><span class="p">[</span><span class="n">i_dim</span><span class="p">][</span><span class="n">i_level</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i_level</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">i_level</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fejer2&#39;</span><span class="p">)):</span>
                    <span class="n">dl_k</span><span class="p">[</span><span class="n">i_level</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">knots_l</span>
                    <span class="n">dl_w</span><span class="p">[</span><span class="n">i_level</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_l</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dl_k</span><span class="p">[</span><span class="n">i_level</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">knots_l</span><span class="p">,</span> <span class="n">knots_l_1</span><span class="p">))</span>
                    <span class="n">dl_w</span><span class="p">[</span><span class="n">i_level</span><span class="p">][</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">weights_l</span><span class="p">,</span> <span class="o">-</span><span class="n">weights_l_1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dl_k</span><span class="p">,</span> <span class="n">dl_w</span></div>

<div class="viewcode-block" id="SparseGrid.calc_tensor_products"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid.calc_tensor_products">[docs]</a>    <span class="k">def</span> <span class="nf">calc_tensor_products</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the tensor products of the knots and the weights.</span>

<span class="sd">        dL_k, dL_w = calc_tensor_products()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dL_k: np.ndarray</span>
<span class="sd">            tensor product of knots</span>
<span class="sd">        dL_w: np.ndarray</span>
<span class="sd">            tensor product of weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make list of all tensor products according to multiindex list &quot;l&quot;</span>
        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;    Generating subgrids ...&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">dl_k</span><span class="p">,</span> <span class="n">dl_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_grid</span><span class="p">()</span>
        <span class="n">l_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_l_level</span><span class="p">()</span>
        <span class="n">dL_k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dL_w</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i_l_level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_level</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">knots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">knots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dl_k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">l_level</span><span class="p">[</span><span class="n">i_l_level</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])][</span><span class="n">i_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dl_w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">l_level</span><span class="p">[</span><span class="n">i_l_level</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">])][</span><span class="n">i_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>

            <span class="c1"># tensor product of knots</span>
            <span class="n">dL_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cartesian</span><span class="p">(</span><span class="n">knots</span><span class="p">))</span>

            <span class="c1"># tensor product of weights</span>
            <span class="n">dL_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">cartesian</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">dL_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">dL_w</span><span class="p">)</span>
        <span class="n">dL_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">dL_k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dL_k</span><span class="p">,</span> <span class="n">dL_w</span></div>

<div class="viewcode-block" id="SparseGrid.calc_coords_weights"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.SparseGrid.calc_coords_weights">[docs]</a>    <span class="k">def</span> <span class="nf">calc_coords_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find similar points in grid and formulate calculate a list containing these points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find similar points in grid and formulate Point list</span>
        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;    Merging subgrids ...&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">dL_w</span><span class="p">,</span> <span class="n">dL_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_tensor_products</span><span class="p">()</span>
        <span class="n">point_number_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dL_w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">point_no</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">epsilon_k</span> <span class="o">=</span> <span class="mf">1E-6</span>
        <span class="n">coords_norm</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">point_number_list</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">not_found</span> <span class="o">=</span> <span class="n">point_number_list</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">dL_k_nf</span> <span class="o">=</span> <span class="n">dL_k</span><span class="p">[</span><span class="n">not_found</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">point_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dL_k_nf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">point_temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dL_k_nf</span> <span class="o">-</span> <span class="n">dL_k_nf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_no</span>
            <span class="n">point_number_list</span><span class="p">[</span><span class="n">not_found</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_temp</span>
            <span class="n">point_no</span> <span class="o">=</span> <span class="n">point_no</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">coords_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dL_k_nf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">)</span>
        <span class="n">point_number_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point_number_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">point_number_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">999</span>

        <span class="k">for</span> <span class="n">i_point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">point_number_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i_point</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dL_w</span><span class="p">[</span><span class="n">point_number_list</span> <span class="o">==</span> <span class="n">i_point</span><span class="p">])</span>

        <span class="c1"># filter for very small weights</span>
        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;    Filter grid for very small weights ...&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">epsilon_w</span> <span class="o">=</span> <span class="mf">1E-8</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">keep_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">epsilon_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">keep_point</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">coords_norm</span> <span class="o">=</span> <span class="n">coords_norm</span><span class="p">[</span><span class="n">keep_point</span><span class="p">]</span>

        <span class="c1"># rescale normalized coordinates in case of normal distributions and &quot;fejer2&quot; or &quot;cc&quot; grids</span>
        <span class="c1"># +- 0.675 * sigma -&gt; 50%</span>
        <span class="c1"># +- 1.645 * sigma -&gt; 90%</span>
        <span class="c1"># +- 1.960 * sigma -&gt; 95%</span>
        <span class="c1"># +- 2.576 * sigma -&gt; 99%</span>
        <span class="c1"># +- 3.000 * sigma -&gt; 99.73%</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;hermite&quot;</span><span class="p">)):</span>
                <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.960</span>

        <span class="c1"># denormalize grid to original parameter space</span>
        <span class="n">vprint</span><span class="p">(</span><span class="s2">&quot;    Denormalizing grid for computations ...&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span> <span class="o">=</span> <span class="n">coords_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">get_denormalized_coordinates</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomGrid"><a class="viewcode-back" href="../../pygpc.grid.html#pygpc.grid.RandomGrid">[docs]</a><span class="k">class</span> <span class="nc">RandomGrid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate RandomGrid object instance.</span>

<span class="sd">    Initialisation</span>
<span class="sd">    --------------</span>
<span class="sd">    RandomGrid(pdf_type, grid_shape, limits, N, seed=None)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of pdf (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        Upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    N: int</span>
<span class="sd">        number of random samples to generate</span>
<span class="sd">    seed: float</span>
<span class="sd">        seeding point to replicate random grids</span>
<span class="sd">    dim: int</span>
<span class="sd">        number of uncertain parameters to process</span>
<span class="sd">    coords: [N_samples x dim] np.ndarray</span>
<span class="sd">        denormalized coordinates xi</span>
<span class="sd">    coords_norm: [N_samples x dim] np.ndarray</span>
<span class="sd">        normalized [-1, 1] coordinates xi</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pdf_type: [N_vars] list of str</span>
<span class="sd">        variable specific type of pdf (&quot;beta&quot;, &quot;normal&quot;)</span>
<span class="sd">    grid_shape: [2 x N_vars] list of list of float</span>
<span class="sd">        shape parameters of PDF</span>
<span class="sd">        beta (jacobi):  [alpha, beta]</span>
<span class="sd">        norm (hermite): [mean, std]</span>
<span class="sd">    limits: [2 x N_vars] list of list of float</span>
<span class="sd">        Upper and lower bounds of PDF</span>
<span class="sd">        beta (jacobi):  [min, max]</span>
<span class="sd">        norm (hermite): [0, 0] (unused)</span>
<span class="sd">    N: int</span>
<span class="sd">        number of random samples to generate</span>
<span class="sd">    seed: float, optional, default=None</span>
<span class="sd">        seeding point to replicate random grids</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_type</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span> <span class="o">=</span> <span class="n">pdf_type</span>  <span class="c1"># pdf_type: &quot;beta&quot;, &quot;normal&quot; [1 x dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid_shape</span>  <span class="c1"># pdf_shape: jacobi:-&gt;[alpha and beta] hermite:-&gt;[mean, variance] list [2 x dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span>  <span class="c1"># limits: [min, max]  list [2 x dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># Number of random samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">)</span>  <span class="c1"># number of dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>  <span class="c1"># seed of random grid (if necessary to reproduce random grid)</span>

        <span class="c1"># generate random samples for each random input variable [N x dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i_dim</span><span class="p">],</span>
                                                             <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># denormalize grid to original parameter space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">get_denormalized_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pygpc</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Konstantin Weise.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>